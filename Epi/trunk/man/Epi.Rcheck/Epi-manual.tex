\documentclass{article}
\usepackage[ae,hyper]{Rd}
\begin{document}
\HeaderA{apc.fit}{Fit an Age-Period-Cohort model to tabular data.}{apc.fit}
\keyword{models}{apc.fit}
\keyword{regression}{apc.fit}
\begin{Description}\relax
Fits the classical five models to tabulated rate data (cases,
person-years) classified by two of age, period, cohort:
Age, Age-drift, Age-Period, Age-Cohort and Age-period. There are no
assumtions about the age, period or cohort classes being of the same
length, or that tabulation should be only by two of the variables.
Only requires that mean age and period for each tabulation unit is given.
\end{Description}
\begin{Usage}
\begin{verbatim}
apc.fit( data,
            A,
            P,
            D,
            Y,
        ref.c,
        ref.p,
         model = c("ns","bs","ls","factor"),
       dr.extr = c("weighted","Holford"),
          parm = c("ACP","APC","AdCP","AdPC","Ad-P-C","Ad-C-P","AC-P","AP-C"),
          npar = c( A=5, P=5, C=5 ),
         scale = 1,
         alpha = 0.05,
    print.AOV = TRUE )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Data frame with (at least) variables, \code{A} (age),
\code{P} (period), \code{D} (cases, deaths) and \code{Y}
(person-years). Cohort (date of birth) is computed as \code{P-A}.
\item[\code{A}] Age; numerical vector with mean age at diagnosis for each unit.
\item[\code{P}] Period; numerical vector with mean date of diagnosis for each
unit.
\item[\code{D}] Cases, deaths; numerical vector.
\item[\code{Y}] Person-years; numerical vector.
\item[\code{ref.c}] Reference cohort, numerical. Defaults to median date of
birth among cases. If used with \code{parm="AdCP"} or \code{parm="AdPC"},
the resdiual cohort effects will be 1 at ref.c
\item[\code{ref.p}] reference period, numerical. Defaults to median date of
diagnosis among cases.
\item[\code{model}] Type of model fitted:
\Itemize{
\item \code{bs} fits a model with B-splines for each of
the terms, with \code{npar} parameters for the terms.
\item \code{ns} fits a model with natural splines for each of
the terms, with \code{npar} parameters for the terms.
\item \code{ls} fits a model with linear splines.
\item \code{factor} fits a factor model with one parameter
per value of \code{A}, \code{P} and \code{C}. \code{npar}
is ignored in this case.} 
\item[\code{dr.extr}] How the drift parameter should be extracted from the
age-period-cohort model. \code{weighted} (default) lets the
weighted average (by marginal no. cases, \code{D}) of the estimated
period and cohort effects have 0 slopw. \code{Holford} uses the
naïve average over all values for the estimated effects,
disregarding the no. cases.
\item[\code{parm}] The parametrization of the effects. The first four all
refer to the ML-fit of the Age-Period-Cohort model, the last four
give Age-effects from a smaller model and residuals relative to
this. If one of the latter is chosen, \code{drift} is ignored. 
Possible values are:
\Itemize{
\item \code{ACP}: ML-estimates. Age-effects as rates for the
reference cohort. Cohort effects as RR relative to the reference
cohort. Period effects constrained to be 0 on average with 0 slope.
\item \code{APC}: ML-estimates. Age-effects as rates for the
reference period. Period effects as RR relative to the reference
period. Cohort effects constrained to be 0 on average with 0 slope.
\item \code{AdCP}: ML-estimates. Age-effects as rates for the
reference cohort. Cohort and period effects constrained to be 0 on
average with 0 slope. These effects do not multiply to the fitted
rates, the drift is missing and needs to be included to produce
the fitted values.
\item \code{AdPC}: ML-estimates. Age-effects as rates for the
reference period. Cohort and period effects constrained to be 0 on
average with 0 slope. These effects do not multiply to the fitted
rates, the drift is missing and needs to be included to produce
the fitted values.
\item \code{Ad-C-P}: Age effects are rates for the reference
cohort in the Age-drift model (cohort drift). Cohort effects are from the model
with cohort alone, using log(fitted values) from the Age-drift
model as offset. Period effects are from the model with period
alone using log(fitted values) from the cohort model as offset.      
\item \code{Ad-P-C}: Age effects are rates for the reference
period in the Age-drift model (period drift). Period effects are from the model
with period alone, using log(fitted values) from the Age-drift
model as offset. Cohort effects are from the model with cohort
alone using log(fitted values) from the period model as offset.      
\item \code{AC-P}: Age effects are rates for the reference
cohort in the Age-Cohort model, cohort effects are RR relative to
the reference cohort. Period effects are from the model
with period alone, using log(fitted values) from the Age-Cohort
model as offset.
\item \code{AP-C}: Age effects are rates for the reference
period in the Age-Period model, period effects are RR relative to
the reference period. Cohort effects are from the model
with cohort alone, using log(fitted values) from the Age-Period
model as offset.
} 
\item[\code{npar}] The number of parameters to use for each of the terms in
the model. It can be a list of three numerical vectors, in which case
these taken as the knots for the age, period and cohort effect, the first
and last element in each vector are used as the boundary knots.
\item[\code{alpha}] The significance level. Estimates are given with
(1-\code{alpha}) confidence limits.
\item[\code{scale}] numeric(1), factor multiplied to the rate estimates before output.
\item[\code{print.AOV}] Should the analysis of deviance table for the models
be printed?
\end{ldescription}
\end{Arguments}
\begin{Value}
An object of class "apc" (recognized by \code{\LinkA{apc.lines}{apc.lines}} and
\code{\LinkA{apc.plot}{apc.plot}}) --- a list with components:
\begin{ldescription}
\item[\code{Age}] Matrix with 4 colums: \code{A.pt} with the ages (equals
\code{unique(A)}) and three columns giving the estimated rates with
c.i.s.
\item[\code{Per}] Matrix with 4 colums: \code{P.pt} with the dates of
diagnosis (equals \code{unique(P)}) and three columns giving the
estimated RRs with c.i.s.
\item[\code{Coh}] Matrix with 4 colums: \code{C.pt} with the dates of birth
(equals \code{unique(P-A)}) and three columns giving the estimated
RRs with c.i.s.
\item[\code{Drift}] A 3 column matrix with drift-estimates and c.i.s: The first row is
the ML-estimate of the drift (as defined by \code{drift}), the
second row is the estimate from the Age-drift model. For the
sequential parametrizations, only the latter is given.
\item[\code{Ref}] Numerical vector of length 2 with reference period and cohort.
If ref.p or ref.c was not supplied the corresponding element is NA.
\item[\code{AOV}] Analysis of deviance table comparing the five classical
models.
\item[\code{Type}] Character string explaining the model and the parametrization.
\item[\code{Knots}] If \code{model} is one of \code{"ns"} or \code{"bs"}, a list
with three components: \code{Age}, \code{Per}, \code{Coh}, each one a
vector of knots. The max and the min are the boundary knots.
\item[\code{Powers}] If \code{model} is \code{"fpol"}, a list
with three components: \code{Age}, \code{Per}, \code{Coh}, each one a
vector of the powers used in the fractional polynomials.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Bendix Carstensen, \url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{References}\relax
The considerations behind the parametrizations used in this function
are given in details in a preprint from Department of Biostatistics in Copenhagen:
\url{http://www.pubhealth.ku.dk/bs/publikationer/rr-06-1.pdf}.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{apc.frame}{apc.frame}}, \code{\LinkA{apc.lines}{apc.lines}}, \code{\LinkA{apc.plot}{apc.plot}}.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
library( Epi )
data(lungDK)

# Taylor a dataframe that meets the requirements
exd <- lungDK[,c("Ax","Px","D","Y")]
names(exd)[1:2] <- c("A","P")

# Two different ways of parametrizing the APC-model, ML
ex.H <- apc.fit( exd, npar=7, model="ns", dr.extr="Holford",  parm="ACP", scale=10^5 )
ex.W <- apc.fit( exd, npar=7, model="ns", dr.extr="weighted", parm="ACP", scale=10^5 )

# Sequential fit, first AC, then P given AC.
ex.S <- apc.fit( exd, npar=7, model="ns", parm="AC-P", scale=10^5 )

# Show the estimated drifts
ex.H[["Drift"]]
ex.W[["Drift"]]
ex.S[["Drift"]]

# Plot the effects
fp <- apc.plot( ex.H )
apc.lines( ex.W, frame.par=fp, col="red" )
apc.lines( ex.S, frame.par=fp, col="blue" )
\end{ExampleCode}
\end{Examples}

\HeaderA{apc.frame}{Produce an empty frame for display of parameter-estimates from
Age-Period-Cohort-models.}{apc.frame}
\keyword{hplot}{apc.frame}
\begin{Description}\relax
A plot is generated where both the age-scale and the cohort/period
scale is on the x-axis. The left vertical axis will be a logarithmic
rate scale referring to age-effects and the right a logarithmic
rate-ratio scale of the same relative extent as the left referring to
the cohort and period effects (rate ratios).

Only an empty plot frame is generated. Curves or points must be added
with \code{points}, \code{lines} or the special utility function
\code{\LinkA{apc.lines}{apc.lines}}.
\end{Description}
\begin{Usage}
\begin{verbatim}
  apc.frame( a.lab,
            cp.lab,
             r.lab,
            rr.lab = r.lab / rr.ref,
            rr.ref = r.lab[length(r.lab)/2],
             a.tic = a.lab,
            cp.tic = cp.lab,
             r.tic = r.lab,
            rr.tic = r.tic / rr.ref,
           tic.fac = 1.3,
             a.txt = "Age",
            cp.txt = "Calendar time",
             r.txt = "Rate per 100,000 person-years",
            rr.txt = "Rate ratio",
               gap = diff(range(c(a.lab, a.tic)))/3,
          col.grid = gray(0.85),
             sides = c(1,2,4) )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{a.lab}] Numerical vector of labels for the age-axis.
\item[\code{cp.lab}] Numerical vector of labels for the cohort-period axis.
\item[\code{r.lab}] Numerical vector of labels for the rate-axis (left vertical)
\item[\code{rr.lab}] Numerical vector of labels for the RR-axis (right vertical)
\item[\code{rr.ref}] At what level of the rate scale is the RR=1 to be.
\item[\code{a.tic}] Location of additional tick marks on the age-scale
\item[\code{cp.tic}] Location of additional tick marks on the cohort-period-scale
\item[\code{r.tic}] Location of additional tick marks on the rate-scale
\item[\code{rr.tic}] Location of additional tick marks on the RR-axis.
\item[\code{tic.fac}] Factor with which to diminish intermediate tick marks
\item[\code{a.txt}] Text for the age-axis (left part of horizontal axis).
\item[\code{cp.txt}] Text for the cohort/period axis (right part of
horizontal axis).
\item[\code{r.txt}] Text for the rate axis (left vertical axis).
\item[\code{rr.txt}] Text for the rate-ratio axis (right vertical axis)
\item[\code{gap}] Gap between the age-scale and the cohort-period scale
\item[\code{col.grid}] Colour of the grid put in the plot.
\item[\code{sides}] Numerical vector indicating on which sides axes should
be drawn and annotated. This option is aimed for multi-panel
displays where axes only are put on the outer plots.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The function produces an empty plot frame for display of results
from an age-period-cohort model, with age-specific rates in the left
side of the frame and cohort and period rate-ratio parameters in the
right side of the frame. There is a gap of \code{gap} between the
age-axis and the calendar time axis, vertical grid lines at
\code{c(a.lab,a.tic,cp.lab,cp.tic)}, and horizontal grid lines at
\code{c(r.lab,r.tic)}.

The function returns a numerical vector of
length 2, with names \code{c("cp.offset","RR.fac")}. The y-axis for
the plot will be a rate scale for the age-effects, and the x-axis will
be the age-scale. The cohort and period effects are plotted by
subtracting the first element (named \code{"cp.offset"}) of the returned result
form the cohort/period, and multiplying  the rate-ratios by the second
element of the returned result (named \code{"RR.fac"}).
\end{Details}
\begin{Value}
A numerical vector of length two, with names
\code{c("cp.offset","RR.fac")}. The first is the offset for the cohort
period-axis, the second the multiplication factor for the rate-ratio
scale.

Side-effect: A plot with axes and grid lines but no points or curves.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc/}
\end{Author}
\begin{References}\relax
\url{http://www.pubhealth.ku.dk/~bxc/APC/notes.pdf}
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{apc.lines}{apc.lines},\LinkA{apc.lines}{apc.lines}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
par( mar=c(4,4,1,4) )
res <-
apc.frame( a.lab=seq(30,90,20), cp.lab=seq(1880,2000,30), r.lab=c(1,2,5,10,20,50),
           a.tic=seq(30,90,10), cp.tic=seq(1880,2000,10), r.tic=c(1:10,1:5*10),
           gap=27 )
res
# What are the axes actually?
par(c("usr","xlog","ylog"))
# How to plot in the age-part: a point at (50,10)
points( 50, 10, pch=16, cex=2, col="blue" )
# How to plot in the cohort-period-part: a point at (1960,0.3)
points( 1960-res[1], 0.3*res[2], pch=16, cex=2, col="red" )
\end{ExampleCode}
\end{Examples}

\HeaderA{apc.lines}{Plot APC-estimates in an APC-frame.}{apc.lines}
\keyword{hplot}{apc.lines}
\begin{Description}\relax
When an APC-frame has been produced by \code{\LinkA{apc.frame}{apc.frame}}, this
function draws a set of estimates from an APC-fit in the frame. An
optional drift parameter can be added to the period parameters and
subtracted from the cohort and age parameters.
\end{Description}
\begin{Usage}
\begin{verbatim}
 apc.lines( A, P, C,
        scale = c("log","ln","rates","inc","RR"),
    frame.par = NULL,
        drift = 0,
           c0 = median( C[,1] ),
           a0 = median( A[,1] ),
           p0 = c0 + a0,
           ci = rep( FALSE, 3 ),
          lwd = c(3,1,1),
          lty = 1,
          col = "black",
         type = "l",
        knots = FALSE,
          ... )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{A}] Age effects. A 4-column matrix with columns age, age-specific
rates, lower and upper c.i. If A is of class \code{apc} (see
\code{\LinkA{apc.fit}{apc.fit}}, \code{P}, \code{C}, \code{c0},
\code{a0} and \code{p0} are ignored, and the estimates from there
plotted.
\item[\code{P}] Period effects. Rate-ratios. Same form as for the age-effects.
\item[\code{C}] Cohort effects. Rate-ratios. Same form as for the age-effects.
\item[\code{scale}] Are effects given on a log-scale? Character variable, one
of \code{"log"}, \code{"ln"}, \code{"rates"}, \code{"inc"},
\code{"RR"}. If \code{"log"} or \code{"ln"} it is assumed that
effects are log(rates) and log(RRs) otherwise the actual effects are
assumed given in \code{A}, \code{P} and \code{C}. If \code{A} is of
class \code{apc}, it is assumed to be \code{"rates"}.
\item[\code{frame.par}] 2-element vector with the cohort-period offset and
RR multiplicator. This will typically be the result from the call of
\code{\LinkA{apc.frame}{apc.frame}}. See this for details.
\item[\code{drift}] The drift parameter to be added to the period effect. If
\code{scale="log"} this is assumed to be on the log-scale, otherwise
it is assumed to be a multiplicative factor per unit of the first
columns of  \code{A}, \code{P} and \code{C} 
\item[\code{c0}] The cohort where the drift is assumed to be 0; the subtracted
drift effect is \code{drift*(C[,1]-c0)}.
\item[\code{a0}] The age where the drift is assumed to be 0.
\item[\code{p0}] The period where the drift is assumed to be 0.
\item[\code{ci}] Should confidence interval be drawn. Logical or
character. If character, any occurrence of \code{"a"} or \code{"A"}
produces confidence intervals for the age-effect. Similarly for
period and cohort.
\item[\code{lwd}] Line widths for estimates, lower and upper confidence limits.
\item[\code{lty}] Linetypes for the three effects.
\item[\code{col}] Colours for the three effects.
\item[\code{type}] What type of lines / points should be used.
\item[\code{knots}] Should knots from the model be shown?
\item[\code{...}] Further parameters to be transmitted to \code{matlines} used
for plotting the three sets of curves.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The drawing of three effects in an APC-frame is a rather trivial task,
and the main purpose of the utility is to provide a function that
easily adds the functionality of adding a drift so that several sets
of lines can be easily produced in the same frame.
\end{Details}
\begin{Value}
A list of three matrices with the effects plotted is
returned invisibly.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{References}\relax
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{apc.frame}{apc.frame}, \\code\{\LinkA{apc.frame}{apc.frame}\}}
\end{SeeAlso}

\HeaderA{apc.plot}{Plot the estimates from a fitted Age-Period-Cohort model}{apc.plot}
\keyword{hplot}{apc.plot}
\begin{Description}\relax
This function plots the estimates created by \code{\LinkA{apc.fit}{apc.fit}} in a single 
graph. It just calls \code{\LinkA{apc.frame}{apc.frame}} after computing some sensible 
values of the parameters, and subsequently plots the estimates using 
\code{\LinkA{apc.lines}{apc.lines}}.
\end{Description}
\begin{Usage}
\begin{verbatim}
apc.plot(obj, r.txt = "Rate", ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{obj}] An object of class \code{apc}. 
\item[\code{r.txt}] The text to put on the vertical rate axis. 
\item[\code{...}] Additional arguments passed on to \code{\LinkA{apc.lines}{apc.lines}}. 
\end{ldescription}
\end{Arguments}
\begin{Value}
A numerical vector of length two, with names
\code{c("cp.offset","RR.fac")}. The first is the offset for the cohort
period-axis, the second the multiplication factor for the rate-ratio
scale. Therefore, if you want to plot at \code{(x,y)} in the right panel,
use \code{(x-res["cp.offset"],y/res["RR.fac"])=(x-res[1],y/res[2])}.
This vector should be supplied for the parameter \code{frame.par} to
\code{\LinkA{apc.lines}{apc.lines}} if more sets of estimates is plotted in the
same graph.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{apc.lines}{apc.lines},\LinkA{apc.lines}{apc.lines},\LinkA{apc.lines}{apc.lines}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data( lungDK )
attach( lungDK )
apc1 <- apc.fit( A=Ax, P=Px, D=D, Y=Y/10^5 )
fp <- apc.plot( apc1 )
apc.lines( apc1, frame.par=fp, drift=1.01, col="red" )
for( i in 1:11 )
  apc.lines( apc1, frame.par=fp, drift=1+(i-6)/100, col=rainbow(12)[i] )
\end{ExampleCode}
\end{Examples}

\HeaderA{bdendo}{A case-control study of endometrial cancer}{bdendo}
\keyword{datasets}{bdendo}
\begin{Description}\relax
The \code{bdendo} data frame has 315 rows and 13 columns.
These data concern a study in which each case of endometrial cancer was
matched with 4 controls. Matching was by date of birth (within one
year), marital status, and residence.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{set}: & Case-control set: a numeric vector  \\
\code{d}: & Case or control: a numeric vector (1=case, 0=control) \\
\code{gall}: & Gall bladder disease: a factor with levels
\code{No} 
\code{Yes}. \\
\code{hyp}: & Hypertension: a factor with levels
\code{No} 
\code{Yes}. \\
\code{ob}: & Obesity: a factor with levels
\code{No} 
\code{Yes}. \\
\code{est}: & A factor with levels
\code{No} 
\code{Yes}. \\
\code{dur}: & Duration of conjugated oestrogen therapy: an ordered factor with levels
\code{0} < \code{1} < \code{2} < \code{3} < \code{4}. \\
\code{non}: & Use of non oestrogen drugs: a factor with levels
\code{No} 
\code{Yes}. \\
\code{duration}: & Months of oestrogen therapy: a numeric vector.  \\
\code{age}: & A numeric vector. \\
\code{cest}: & Conjugated oestrogen dose: an ordered factor with levels
\code{0} < \code{1} < \code{2} < \code{3}. \\
\code{agegrp}: & A factor with levels
\code{55-59} 
\code{60-64} 
\code{65-69} 
\code{70-74} 
\code{75-79} 
\code{80-84} \\
\code{age3}: & a factor with levels
\code{<64} 
\code{65-74} 
\code{75+}  \\
}
\end{Format}
\begin{Source}\relax
Breslow NE, and Day N, Statistical Methods in Cancer Research. Volume
I: The Analysis of Case-Control Studies. IARC Scientific
Publications, IARC:Lyon, 1980.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(bdendo)
\end{ExampleCode}
\end{Examples}

\HeaderA{bdendo11}{A 1:1 subset of the endometrial cancer case-control study}{bdendo11}
\keyword{datasets}{bdendo11}
\begin{Description}\relax
The \code{bdendo11} data frame has 126 rows and 13 columns.
This is a subset of the dataset \code{\LinkA{bdendo}{bdendo}} in which each case
was matched with a single control.
\end{Description}
\begin{Source}\relax
Breslow NE, and Day N, Statistical Methods in Cancer Research. Volume
I: The Analysis of Case-Control Studies. IARC Scientific
Publications, IARC:Lyon, 1980.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(bdendo11)
\end{ExampleCode}
\end{Examples}

\HeaderA{births}{Births in a London Hospital}{births}
\keyword{datasets}{births}
\begin{Description}\relax
Data from 500 singleton births in a London Hospital
\end{Description}
\begin{Usage}
\begin{verbatim}data(births)\end{verbatim}
\end{Usage}
\begin{Format}\relax
A data frame with 500 observations on the following 8 variables.
\Tabular{rl}{
\code{id}: & Identity number for mother and baby. \\
\code{bweight}: & Birth weight of baby. \\
\code{lowbw}: & Indicator for birth weight less than 2500 g. \\
\code{gestwks}: & Gestation period. \\
\code{preterm}: & Indicator for gestation period less than 37 weeks. \\
\code{matage}: & Maternal age. \\
\code{hyp}: & Indicator for maternal hypertension. \\
\code{sex}: & Sex of baby: 1:Male, 2:Female. \\
}
\end{Format}
\begin{Source}\relax
Anonymous
\end{Source}
\begin{References}\relax
Michael Hills and Bianca De Stavola (2002). A Short Introduction to
Stata 8 for Biostatistics, Timberlake Consultants Ltd
\url{http://www.timberlake.co.uk}
\end{References}
\begin{Examples}
\begin{ExampleCode}
data(births)
\end{ExampleCode}
\end{Examples}

\HeaderA{blcaIT}{Bladder cancer mortality in Italian males}{blcaIT}
\keyword{datasets}{blcaIT}
\begin{Description}\relax
Number of deaths from bladder cancer and person-years in the Italian
male population 1955--1979, in ages 25--79.
\end{Description}
\begin{Format}\relax
A data frame with 55 observations on the following 4 variables:
\Tabular{rl}{
\code{age}:    & Age at death. Left endpoint of age class \\
\code{period}: & Period of death. Left endpoint of period \\
\code{D}:      & Number of deaths \\
\code{Y}:      & Number of person-years.
}
\end{Format}
\begin{Examples}
\begin{ExampleCode}
data(blcaIT)
\end{ExampleCode}
\end{Examples}

\HeaderA{brv}{Bereavement in an elderly cohort}{brv}
\keyword{datasets}{brv}
\begin{Description}\relax
The \code{brv} data frame has 399 rows and 11 columns.
The data concern the possible effect of marital bereavement on
subsequent mortality. They arose from a survey of the physical and
mental health of a cohort of 75-year-olds in one large general
practice. These data concern mortality up to 1 January, 1990 (although
further follow-up has now taken place).

Subjects included all lived with a living spouse when they entered the
study. There are three distinct groups of such subjects: (1) those in
which both members of the couple were over 75 and therefore included in
the cohort, (2) those whose spouse was below 75 (and was not, therefore,
part of the main cohort study), and (3) those living in larger
households (that is, not just with their spouse).
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{id}: & subject identifier, a numeric vector \\
\code{couple}: & couple identifier, a numeric vector \\
\code{dob}: & date of birth, a date \\
\code{doe}: & date of entry into follow-up study, a date \\
\code{dox}: & date of exit from follow-up study, a date \\
\code{dosp}: & date of death of spouse, a date (if the spouse was still alive
at the end of follow-up, this was coded to January 1, 2000) \\ 
\code{fail}: & status at end of follow-up,
a numeric vector (0=alive,1=dead) \\
\code{group}: & see Description, a numeric vector \\
\code{disab}: & disability score, a numeric vector \\
\code{health}: & perceived health status score, a numeric vector \\
\code{sex}: & a factor with levels
\code{Male} 
\code{Female}
}
\end{Format}
\begin{Source}\relax
Jagger C, and Sutton CJ, Death after Marital Bereavement. Statistics in
Medicine, 10:395-404, 1991. (Data supplied by Carol Jagger).
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(brv)
\end{ExampleCode}
\end{Examples}

\HeaderA{cal.yr}{Functions to convert character, factor and various date objects into a number,
and vice versa.}{cal.yr}
\aliasA{as.Date.cal.yr}{cal.yr}{as.Date.cal.yr}
\aliasA{as.Date.numeric}{cal.yr}{as.Date.numeric}
\keyword{manip}{cal.yr}
\keyword{chron}{cal.yr}
\begin{Description}\relax
Dates are converted to a numerical value, giving the calendar year as
a fractional number. 1 January 1970 is converted to 1970.0, and other
dates are converted by assuming that years are all 365.25 days long,
so inaccuracies may arise, for example, 1 Jan 2000 is converted to
1999.999. Differences between converted values will be 1/365.25 of the 
difference between corresponding \code{\LinkA{Date}{Date}} objects.
\end{Description}
\begin{Usage}
\begin{verbatim}
  cal.yr(x, format)
  as.Date.cal.yr( x, ... )
  as.Date.numeric( x, ..., unit="d" )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A factor or character vector, representing a date in format
\code{format}, or an object of class
\code{\LinkA{Date}{Date}},
\code{\LinkA{POSIXlt}{POSIXlt}},
\code{\LinkA{POSIXct}{POSIXct}},
\code{\LinkA{date}{date}},
\code{dates} or
\code{chron} (the latter two requires the \code{chron} package).
\item[\code{format}] Format of the date values if \code{x} is factor or character
\item[\code{unit}] Which units are the date measured in, \code{"y"} for years,
\code{"d"} for days.
\item[\code{...}] Arguments passed on from other methods.
\end{ldescription}
\end{Arguments}
\begin{Value}
\code{cal.yr} returns a numerical vector of the same length as
\code{x}, of class \code{c("cal.yr","numeric")}.

\code{as.Date.cal.yr} and \code{as.Date.numeric}
return \code{\LinkA{Date}{Date}} objects.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center \& Dept. of Biostatistics,
University of Copenhagen, \email{bxc@steno.dk},
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{DateTimeClasses}{DateTimeClasses}},
\code{\LinkA{Date}{Date}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
 # Charcter vector of dates:
 birth <- c("14/07/1852","01/04/1954","10/06/1987","16/05/1990",
            "01/01/1996","01/01/1997","01/01/1998","01/01/1999")
 # Proper conversion to class "Date":
 birth.dat <- as.Date( birth, format="%d/%m/%Y" )
 # Converson of character to class "cal.yr"
 bt.yr <- cal.yr( birth, format="%d/%m/%Y" )
 # Back to class "Date":
 bt.dat <- as.Date( bt.yr )
 # Numerical calculation of days since 1.1.1970:
 days <- Days <- (bt.yr-1970)*365.25
 # Blunt assignment of class:
 class( Days ) <- "Date"
 # Then data.frame() to get readable output of results:
 data.frame( birth, birth.dat, bt.yr, bt.dat, days, Days, round(Days) )
\end{ExampleCode}
\end{Examples}

\HeaderA{ccwc}{Generate a nested case-control study}{ccwc}
\keyword{datagen}{ccwc}
\begin{Description}\relax
Given the basic outcome variables for a cohort study: the time of entry 
to the cohort, the time of exit and the reason for exit ("failure" or
"censoring"), this function computes risk sets and generates a matched
case-control study in which each case is compared with a set of controls
randomly sampled from the appropriate risk set. Other variables may be
matched when selecting controls.
\end{Description}
\begin{Usage}
\begin{verbatim}
ccwc(entry=0, exit, fail, origin=0, controls=1, match=list(), include=list(), data=NULL, silent=F)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{entry}] Time of entry to follow-up

\item[\code{exit}] Time of exit from follow-up

\item[\code{fail}] Status on exit (1=Fail, 0=Censored)

\item[\code{origin}] Origin of analysis time scale

\item[\code{controls}] The number of controls to be selected for each case

\item[\code{match}] List of categorical variables on which to match cases and controls

\item[\code{include}] List of other variables to be carried across into the case-control
study

\item[\code{data}] Data frame in which to look for input variables

\item[\code{silent}] If  False, echos a . to the screen for each case-control set
created; otherwise produces no output.

\end{ldescription}
\end{Arguments}
\begin{Value}
The case-control study, as a  dataframe containing:
\begin{ldescription}
\item[\code{Set}] case-control set number

\item[\code{Map}] row number of record in input dataframe

\item[\code{Time}] failure time of the case in this set

\item[\code{Fail}] failure status (1=case, 0=control)

\end{ldescription}

These are followed by the matching variables, and finally by the
variables in the \code{include} list
\end{Value}
\begin{Author}\relax
David Clayton
\end{Author}
\begin{References}\relax
Clayton and Hills, Statistical Models in Epidemiology, Oxford
University Press, Oxford:1993.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
#
# For the diet and heart dataset, create a nested case-control study
# using the age scale and matching on job
#
data(diet)
dietcc <- ccwc(doe, dox, chd, origin=dob, controls=2, data=diet,
               include=energy, match=job)
\end{ExampleCode}
\end{Examples}

\HeaderA{ci.cum}{Compute cumulative sum of estimates.}{ci.cum}
\keyword{models}{ci.cum}
\keyword{regression}{ci.cum}
\begin{Description}\relax
Computes the cumulative sum of parameter functions and the
standard error of it. Optionally the exponential is applied to the
parameter functions before it is cumulated.
\end{Description}
\begin{Usage}
\begin{verbatim}
ci.cum( obj,
    ctr.mat = NULL,
     subset = NULL,
       intl = 1,
      alpha = 0.05,
        Exp = TRUE )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{obj}] A model object. 
\item[\code{ctr.mat}] Contrast matrix defining the parameter functions from
the parameters of the model. 
\item[\code{subset}] Subset of the parameters of the model to which
\code{ctr.mat} should be applied. 
\item[\code{intl}] Interval length for the cumulation. Either a constant or
a numerical vector of length \code{nrow(ctr.mat)}. 
\item[\code{alpha}] Significance level used when computing confidence limits. 
\item[\code{Exp}] Should the parameter function be exponentiated before it is
cumulated? 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The purpose of this function is to compute cumulative rate based on a
model for the rates. If the model is a multiplicative model for the
rates, the purpose of \code{ctr.mat} is to return a vector of rates or
log-rates when applied to the coefficients of the model. If log-rates
are returned, the they should be exponentiated before cumulated, and
the variances computed accordingly. Since log-linear models are the most
common the \code{Exp} parameter defaults to TRUE.
\end{Details}
\begin{Value}
A matrix with 4 columns: Estimate, lower and upper c.i. and standard
error. The numebr of rows equals \code{nrow(ctr.mat)} if \code{zero} if
FALSE, otherwise \code{nrow(ctr.mat)+1}, because an initial row of 0s
is added.
\end{Value}
\begin{Author}\relax
Bendix Carstensen,
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
See also \code{\LinkA{ci.lin}{ci.lin}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# Packages required for this example
library( splines )
library( survival )
data( lung )
par( mfrow=c(1,2) )

# Plot the Kaplan-meier-estimator
#
plot( survfit( Surv( time, status==2 ), data=lung ) )

# Cut the follow-up every 10 days
#
dx <- W.Lexis( exit=time, fail=(status==2), breaks=seq(0,1100,10), data=lung )
str( dx )

# Fit a Poisson model with a natural spline for the effect of time.
# Note that "Time" is the left endpoint of the interval in the dataframe dx.
#
MM <- ns( dx$Time, knots=c(50,100,200,400,700), intercept=TRUE )
mp <- glm( Fail ~ MM - 1 + offset(log(Exit-Entry)),
                  family=poisson, data=dx, eps=10^-8, maxit=25 )

# Contrast matrix to extract effects, i.e. matrix to multiply with the
# coefficients to produce the log-rates: unique rows of MM, in time order.
#
T.pt <- sort( unique( dx$Time ) )
T.wh <- match( T.pt, dx$Time )
Lambda <- ci.cum( mp, ctr.mat=MM[T.wh,], intl=diff(c(0,T.pt)) )

# Put the estimated survival function on top of the KM-estimator
#
matlines( c(0,T.pt[-1]), exp(-Lambda[,1:3]), lwd=c(3,1,1), lty=1, col="Red" )

# Extract and plot the fitted intensity function
#
lambda <- ci.lin( mp, ctr.mat=MM[T.wh,], Exp=TRUE )
matplot( T.pt, lambda[,5:7]*10^3, type="l", lwd=c(3,1,1), col="black", lty=1,
         log="y", ylim=c(0.2,20) )
\end{ExampleCode}
\end{Examples}

\HeaderA{ci.lin}{Compute linear functions of parameters with s.e.}{ci.lin}
\keyword{models}{ci.lin}
\keyword{regression}{ci.lin}
\begin{Description}\relax
For a given model object the function computes a linear function of
the parameters and the corresponding standard errors, p-values and
confidence intervals.
\end{Description}
\begin{Usage}
\begin{verbatim}
ci.lin( obj,
    ctr.mat = NULL,
     subset = NULL,
      diffs = FALSE,
       fnam = !diffs,
       vcov = FALSE,
      alpha = 0.05,
        Exp = FALSE )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{obj}] A model object (of class \code{lm}, \code{glm}, \code{lme},
\code{coxph} or \code{polr}). 

\item[\code{ctr.mat}] Contrast matrix to be multiplied to the parameter
vector, i.e. the desired linear function of the parameters.
\item[\code{subset}] The subset of the parameters to be used. If given as a
character vector, the elements are in turn matched against the
parameter names (using \code{grep}) to find the subset. Repeat
parameters may result from using a character vector. This is
considered a facility.
\item[\code{diffs}] If TRUE, all differences between parameters
in the subset are computed. \code{ctr.mat} is ignored. If \code{obj}
inherits from \code{lm}, and \code{subset} is given as a string
\code{subset} is used to search among the factors in the model and
differences of all factor levels for the first match are shown.
If \code{subset} does not match any of the factors in the model, all
pairwise differences between parameters matching are returned.
\item[\code{fnam}] Should the common part of the parameter names be included
with the annotation of contrasts? Ignored if \code{diffs==T}. If a
sting is supplied this will be prefixed to the labels.
\item[\code{vcov}] Should the covariance matrix of the set of parameters be
returned? If this is set, \code{Exp} is ignored.
\item[\code{alpha}] Significance level for the confidence intervals.
\item[\code{Exp}] If \code{TRUE} columns 5:6 are replaced with exp( columns 1,5,6 ).
\end{ldescription}
\end{Arguments}
\begin{Value}
A matrix with number of rows and rownames as \code{ctr.mat}. The
columns are Estimate, Std.Err, z, P, 2.5\% and 97.5\%.
If \code{vcov=TRUE} a list with components \code{est}, the desired
functional of the parameters and \code{vcov}, the variance
covariance matrix of this, is returned but not printed.
If code{Exp==TRUE} the confidence intervals for the parameters are
replaced with three columns: exp(estimate,c.i.).
\end{Value}
\begin{Author}\relax
Bendix Carstensen,
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{Examples}
\begin{ExampleCode}
# Bogus data:
f <- factor( sample( letters[1:5], 200, replace=TRUE ) )
g <- factor( sample( letters[1:3], 200, replace=TRUE ) )
x <- rnorm( 200 )
y <- 7 + as.integer( f ) * 3 + 2 * x + 1.7 * rnorm( 200 )

# Fit a simple model:
mm <- lm( y ~ x + f + g )
ci.lin( mm ) 
ci.lin( mm, subset=3:6, diff=TRUE, fnam=FALSE )
ci.lin( mm, subset=3:6, diff=TRUE, fnam=TRUE )
ci.lin( mm, subset="f", diff=TRUE, fnam="f levels:" )
print( ci.lin( mm, subset="g", diff=TRUE, fnam="gee!:", vcov=TRUE ) )

# Use character defined subset to get ALL contrasts:
ci.lin( mm, subset="f", diff=TRUE )
\end{ExampleCode}
\end{Examples}

\HeaderA{ci.pd}{Compute confidence limits for a difference of two independent proportions.}{ci.pd}
\keyword{distribution}{ci.pd}
\keyword{htest}{ci.pd}
\begin{Description}\relax
The usual formula for the c.i. of at difference of proportions is
inaccurate. Newcombe has compared 11 methods and method 10 in his
paper looks like a winner. It is implemented here.
\end{Description}
\begin{Usage}
\begin{verbatim}
ci.pd(aa, bb=NULL, cc=NULL, dd=NULL,
     method = "Nc",
      alpha = 0.05, conf.level=0.95,
     digits = 3,
      print = TRUE,
detail.labs = FALSE )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{aa}] Numeric vector of successes in sample 1. Can also be a
matrix or array (see details).
\item[\code{bb}] Successes in sample 2.
\item[\code{cc}] Failures in sample 1.
\item[\code{dd}] Failures in sample 2.
\item[\code{method}] Method to use for calculation of confidence interval, see
"Details".
\item[\code{alpha}] Significance level
\item[\code{conf.level}] Confidence level
\item[\code{print}] Should an account of the two by two table be printed.
\item[\code{digits}] How many digits should the result be rounded to if printed.
\item[\code{detail.labs}] Should the computing of probability differences be
reported in the labels.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Implements method 10 from Newcombe(1998) (method="Nc") or from
Agresti \& Caffo(2000) (method="AC").

\code{aa}, \code{bb}, \code{cc} and \code{dd} can be vectors.
If \code{aa} is a matrix, the elements \code{[1:2,1:2]} are used, with
successes \code{aa[,1:2]}. If \code{aa} is a three-way table or array,
the elements \code{aa[1:2,1:2,]} are used.
\end{Details}
\begin{Value}
A matrix with three columns: probability difference, lower and upper
limit. The number of rows equals the length of the vectors  \code{aa},
\code{bb}, \code{cc} and \code{dd} or, if \code{aa} is a 3-way matrix,
\code{dim(aa)[3]}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Esa Läärä.
\url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{References}\relax
RG Newcombe: Interval estimation for the difference between
independent proportions. Comparison of eleven methods. Statistics in
Medicine, 17, pp. 873-890, 1998.

A Agresti \& B Caffo: Simple and effective confidence intervals for
proportions and differences of proportions result from adding two
successes and two failures. The American Statistician,
54(4), pp. 280-288, 2000.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{twoby2}{twoby2}}, \code{\LinkA{binom.test}{binom.test}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
( a <- matrix( sample( 10:40, 4 ), 2, 2 ) )
ci.pd( a )
twoby2( t(a) )
prop.test( t(a) )
( A <- array( sample( 10:40, 20 ), dim=c(2,2,5) ) )
ci.pd( A )
ci.pd( A, detail.labs=TRUE, digits=3 )
\end{ExampleCode}
\end{Examples}

\HeaderA{detrend}{Projection of a model matrix on to the orthogonal
complement of a trend.}{detrend}
\keyword{array}{detrend}
\begin{Description}\relax
The columns of the model matrix \code{M} is projected on the
orthogonal complement to the matrix \code{(1,t)}. Orthogonality 
is defined w.r.t. an inner product defined by the weights \code{weight}.
\end{Description}
\begin{Usage}
\begin{verbatim}
  detrend( M, t, weight = rep(1, nrow(M)) )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{M}] A model matrix. 
\item[\code{t}] The trend defining a subspace. A numerical vector of length
\code{nrow(M)} 
\item[\code{weight}] Weights defining the inner product of vectors \code{x}
and \code{y} as \code{sum(x*w*y)}.
A numerical vector of length \code{nrow(M)}, defaults to a vector of
\code{1}s.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The functions is intended to be used in parametrization of
age-period-cohort models.
\end{Details}
\begin{Value}
A full-rank matrix with columns orthogonal to \code{(1,t)}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc}, with help from Peter Dalgaard.
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{projection.ip}{projection.ip}}
\end{SeeAlso}

\HeaderA{diet}{Diet and heart data}{diet}
\keyword{datasets}{diet}
\begin{Description}\relax
The \code{diet} data frame has 337 rows and 14 columns.
The data concern a subsample of subjects drawn from larger cohort
studies of the incidence of coronary heart disease (CHD). These subjects
had all completed a 7-day weighed dietary survey while taking part in
validation studies of dietary questionnaire methods. Upon the closure of
the MRC Social Medicine Unit, from where these studies were directed, it
was found that 46 CHD events had occurred in this group, thus allowing a
serendipitous study of the relationship between diet and the incidence
of CHD.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{id}: & subject identifier, a numeric vector. \\
\code{doe}: & date of entry into follow-up study, a
\code{\LinkA{Date}{Date}} variable. \\
\code{dox}: & date of exit from the follow-up study, a
\code{\LinkA{Date}{Date}} variable. \\
\code{dob}: & date of birth, a
\code{\LinkA{Date}{Date}} variable. \\
\code{y}: & - number of years at risk, a numeric vector. \\
\code{fail}: & status on exit, a numeric vector (codes 1, 3, 11, and
13 represent CHD events) \\
\code{job}: & occupation, a factor with levels
\code{Driver} 
\code{Conductor} 
\code{Bank worker} \\
\code{month}: & month of dietary survey, a numeric vector \\
\code{energy}: & total energy intake (KCal per day/100), a numeric
vector \\
\code{height}: & (cm), a numeric vector \\
\code{weight}: & (kg), a numeric vector \\
\code{fat}: &   fat intake (g/day), a numeric vector \\
\code{fibre}: & dietary fibre intake (g/day), a numeric vector \\
\code{energy.grp}: & high daily energy intake, a factor with levels
\code{<=2750 KCal}
\code{>2750 KCal} \\
\code{chd}: & CHD event, a numeric vector (1=CHD event, 0=no event) \\
}
\end{Format}
\begin{Source}\relax
The data are described and used extensively by Clayton and Hills,
Statistical Models in Epidemiology, Oxford University Press,
Oxford:1993. They were rescued from destruction by David Clayton and
reentered from paper printouts.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(diet)
# Illustrate the follow-up in a Lexis diagram
Lexis.diagram( age=c(30,75), date=c(1965,1990),
               entry.date=cal.yr(doe), exit.date=cal.yr(dox), birth.date=cal.yr(dob), 
               fail=(fail>0), pch.fail=c(NA,16), col.fail=c(NA,"red"), cex.fail=1.0,
               data=diet )

\end{ExampleCode}
\end{Examples}

\HeaderA{effx.match}{Function to calculate effects for individually matched case-control studies}{effx.match}
\keyword{models}{effx.match}
\keyword{regression}{effx.match}
\begin{Description}\relax
The function calculates the effects of an exposure on a response,
possibly stratified by a stratifying variable, and/or controlled for one
of more confounding variables.
\end{Description}
\begin{Usage}
\begin{verbatim}
effx.match(response,
exposure,
match,
strata=NULL,
control=NULL,
base=1,
sigdig=3,
alpha=0.05,
data=NULL) 
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{response}] The \code{response} variable - must be numeric
\item[\code{exposure}] The \code{exposure} variable can be numeric or a factor
\item[\code{match}] The variable which identifies the matched sets
\item[\code{strata}] The \code{strata} stratifying variable - must be a factor
\item[\code{control}] The \code{control} variable(s). These are passed as a
list if there are more than one of them.
\item[\code{base}] Baseline for the effects of a categorical exposure, default 1
\item[\code{sigdig}] Number of significant digits for the effects, default 3
\item[\code{alpha}] 1 - confidence level
\item[\code{data}] \code{data} refers to the data used to evaluate the function
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Effects are calculated odds ratios.
The function is a wrapper for clogit, from the survival package.
The k-1 effects for a categorical  exposure with k levels are relative 
to a baseline which, by default, is the first level. The effect of a metric (quantitative) 
exposure is calculated per unit of exposure.
The exposure variable can be numeric or a factor, but if it is an ordered factor the order will be ignored.
\end{Details}
\begin{Value}
\begin{ldescription}
\item[\code{comp1 }] Effects of exposure
\item[\code{comp2 }] Tests of significance
\end{ldescription}
\end{Value}
\begin{Section}{Warning}
The function attaches the frame specified in the
\code{data=} argument, so there is a possibility that a variable in the
Global environment is masked by the attached frame. Watch out for this
warning in the output!
\end{Section}
\begin{Author}\relax
Michael Hills
\end{Author}
\begin{References}\relax
www.mhills.pwp.blueyonder.co.uk
\end{References}
\begin{Examples}
\begin{ExampleCode}
library(Epi)
library(survival)
data(bdendo)

# d is the case-control variable, set is the matching variable.
# The variable est is a factor and refers to estrogen use (yes,no)
# The variable age is numeric and refers to estrogen use (yes,no)
# effect of est on the odds of being a case
effx.match(d,exposure=est,match=set,data=bdendo)
# effect of age on the odds of being a case
effx.match(d,exposure=age,match=set,data=bdendo)
\end{ExampleCode}
\end{Examples}

\HeaderA{effx}{Function to calculate effects}{effx}
\keyword{models}{effx}
\keyword{regression}{effx}
\begin{Description}\relax
The function calculates the effects of an exposure on a response,
possibly stratified by a stratifying variable, and/or controlled for one
of more confounding variables.
\end{Description}
\begin{Usage}
\begin{verbatim}
effx( response, type = "metric",
                 fup = NULL,     
            exposure,     
              strata = NULL,  
             control = NULL,
             weights = NULL,
               alpha = 0.05,   
                base = 1,             
              sigdig = 3,     
                data = NULL )    
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{response}] The \code{response} variable - must be numeric
\item[\code{type}] The type of response\code{type} - must be one of "metric",
"binary", "failure", or "count"
\item[\code{fup}] The \code{fup} variable contains the follow-up time for a
failure response
\item[\code{exposure}] The \code{exposure} variable can be numeric or a factor
\item[\code{strata}] The \code{strata} stratifying variable - must be a factor
\item[\code{control}] The \code{control} variable(s) - these are passed as a
list of there are more than one.
\item[\code{weights}] Weights
\item[\code{base}] Baseline for the effects of a categorical exposure, default 1
\item[\code{sigdig}] Number of significant digits for the effects, default 3
\item[\code{alpha}] 1 - confidence level
\item[\code{data}] \code{data} refers to the data used to evaluate the function
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The function is a wrapper for glm. Effects are calculated as
differences in means for a metric response, odds ratios for a binary
response, and rate ratios for a failure or count response.  

The k-1 effects for a categorical exposure with k levels are relative
to a baseline which, by default, is the first level. The effect of a
metric (quantitative) exposure is calculated per unit of exposure. 

The exposure variable can be numeric or a factor, but if it is an
ordered factor the order will be ignored.
\end{Details}
\begin{Value}
\begin{ldescription}
\item[\code{comp1 }] Effects of exposure
\item[\code{comp2 }] Tests of significance
\end{ldescription}
\end{Value}
\begin{Section}{Warning}
The function attaches the frame specified in the
\code{data=} argument, so there is a possibility that a variable in the
Global environment is masked by the attached frame. Watch out for this
warning in the output!
\end{Section}
\begin{Author}\relax
Michael Hills
\end{Author}
\begin{References}\relax
www.mhills.pwp.blueyonder.co.uk
\end{References}
\begin{Examples}
\begin{ExampleCode}
library(Epi)
data(births)
births$hyp <- factor(births$hyp,labels=c("normal","hyper"))
births$sex <- factor(births$sex,labels=c("M","F"))

# bweight is the birth weight of the baby in gms, and is a metric
# response (the default) 

# effect of hypertension on birth weight
effx(bweight,exposure=hyp,data=births) 
# effect of hypertension on birth weight stratified by sex
effx(bweight,exposure=hyp,strata=sex,data=births) 
# effect of hypertension on birth weight controlled for sex
effx(bweight,exposure=hyp,control=sex,data=births) 
# effect of gestation time on birth weight
effx(bweight,exposure=gestwks,data=births) 
# effect of gestation time on birth weight stratified by sex
effx(bweight,exposure=gestwks,strata=sex,data=births) 
# effect of gestation time on birth weight controlled for sex
effx(bweight,exposure=gestwks,control=sex,data=births) 

# lowbw is a binary response coded 1 for low birth weight and 0 otherwise
# effect of hypertension on low birth weight
effx(lowbw,type="binary",exposure=hyp,data=births)
# etc.
\end{ExampleCode}
\end{Examples}

\HeaderA{ewrates}{Rates of lung and nasal cancer mortality, and total mortality.}{ewrates}
\keyword{datasets}{ewrates}
\begin{Description}\relax
England and Wales mortality rates from lung cancer, nasal cancer,
and all causes 1936 - 1980. The 1936 rates are repeated as 1931 rates in
order to accomodate follow up for the \code{\LinkA{nickel}{nickel}} study.
\end{Description}
\begin{Usage}
\begin{verbatim}data(ewrates)\end{verbatim}
\end{Usage}
\begin{Format}\relax
A data frame with 150 observations on the following 5 variables:
\Tabular{rl}{
\code{id}: & Subject identifier (numeric) \\
\code{year}  & Calendar period, 1931: 1931--35, 1936: 1936--40,
\ldots \\
\code{age}   & Age class: 10: 10--14, 15:15--19, \ldots  \\
\code{lung}  & Lung cancer mortality rate per 1,000,000 py. \\
\code{nasal} & Nasal cancer mortality rate per 1,000,000 py. \\
\code{other} & All cause mortality rate per 1,000,000 py.
}
\end{Format}
\begin{Source}\relax
From Breslow and Day, Vol II, Appendix IX.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(ewrates)
str(ewrates)
\end{ExampleCode}
\end{Examples}

\HeaderA{ex1}{Split follow-up time along a timescale}{ex1}
\keyword{manip}{ex1}
\keyword{datagen}{ex1}
\begin{Description}\relax
Splits follow-up time at prespecified points of follow-up.
\end{Description}
\begin{Usage}
\begin{verbatim}
ex1( enter, exit, fail, origin = 0, scale = 1, breaks,
     data = data.frame(enter, exit, fail),
     Expand = 1:nrow(data) )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{enter}] Date of entry einto the study (start of follow-up). Numeric.
\item[\code{exit}] Date of termination of follow-up. Numeric.
\item[\code{fail}] Status at exit from the study.
\item[\code{origin}] Origin of the timescale to split on. Specified on the
input timescale, i.e. that of \code{enter} and \code{exit}.
\item[\code{scale}] Scaling between input and analysis timescale.
\item[\code{breaks}] Breakpoints on the analysis timescale. Follow-up before
\code{min(breaks)} and and ater \code{max(breks)} is discarded.
\item[\code{data}] Dataframe of variables to carry over to the output.
\item[\code{Expand}] Variable identifying original records.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
If \code{entry} and \code{exit} are given in days (for example as
\code{Date} variables, and we want follow-up cut at 5-year age
intervals, the we should choose \code{origin} equal to bithdate, scale
equal to 365.25 and breaks as \code{seq(0,100,5)}. Thus the input
timescale is calendar tiem measured in days, and output timescale is
age measured in years.
\end{Details}
\begin{Value}
A dataframe with one row per follow-up interval, and variables as in
\code{data}, preceded by the variables:
\begin{ldescription}
\item[\code{Expand}] Identification of the rows from the input dataframe.
\item[\code{Enter}] Entry date for the interval.
\item[\code{Exit}] Exit date for the interval.
\item[\code{Fail}] Failure indicator for end of the current interval.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\email{bxc@steno.dk}, \url{www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},
\code{\LinkA{isec}{isec}},
\code{\LinkA{icut}{icut}},
\code{\LinkA{fcut1}{fcut1}},
\code{\LinkA{ex1}{ex1}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
one <- round( runif( 15, 0, 10 ), 1 )
two <- round( runif( 15, 0, 10 ), 1 )
doe <- pmin( one, two )
dox <- pmax( one, two )
# Goofy data rows to test possibly odd behaviour
doe[1:3] <- dox[1:3] <- 8
dox[2] <- 6
dox[3] <- 7.5
# Some failure indicators
fail <- sample( 0:1, 15, replace=TRUE, prob=c(0.7,0.3) )
# Split follow-up:
ex1( doe, dox, fail, breaks=0:10 )
\end{ExampleCode}
\end{Examples}

\HeaderA{expand.data}{Function to expand data for regression analysis of interval censored
data.}{expand.data}
\keyword{models}{expand.data}
\keyword{regression}{expand.data}
\keyword{survival}{expand.data}
\begin{Description}\relax
This is a utility function.

The original records with \code{first.well}, \code{last.well} and
\code{first.ill} are
expanded to multiple records; several for each interval where the
person is known to be well and one where the person is known to fail.
At the same time columns for the covariates needed to estimate rates
and the response variable are generated.
\end{Description}
\begin{Usage}
\begin{verbatim}
expand.data(fu, formula, breaks, data)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{fu}] A 3-column matrix with \code{first.well}, \code{last.well} and
\code{first.ill} in each row.
\item[\code{formula}] Model fromula, used to derive the model matrix.
\item[\code{breaks}] Defines the intervals in which the baseline rate is
assumed constant. All follow-up before the first and after the
last break is discarded.
\item[\code{data}] Datafrem in which \code{fu} and \code{formula} is interpreted.
\end{ldescription}
\end{Arguments}
\begin{Value}
Returns a list with three components
\begin{ldescription}
\item[\code{rates.frame}] Dataframe of covariates for estimation of the
baseline rates --- one per interval defined by \code{breaks}.
\item[\code{cov.frame}] Dataframe for estimation of the covariate effects. A
data-framed version of the designmatrix from \code{formula}.
\item[\code{y}] Response vector.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Martyn Plummer, \email{plummer@iarc.fr}
\end{Author}
\begin{References}\relax
B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Icens}{Icens}}
\code{\LinkA{fit.mult}{fit.mult}}
\code{\LinkA{fit.add}{fit.add}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
  \end{ExampleCode}
\end{Examples}

\HeaderA{fcut}{Cuts follow-up time at multiple failure times.}{fcut}
\keyword{manip}{fcut}
\keyword{datagen}{fcut}
\begin{Description}\relax
This function cuts the follow-up time at multiple failure times
allowing a person to stay at risk between and after the laset
failure. It is aimed at processing of recurrent events. Failure times
outside the interval (\code{enter},\code{exit}) are ignored.
\end{Description}
\begin{Usage}
\begin{verbatim}
fcut( enter, exit, dof, fail = 0,
      data = data.frame(enter, exit),
      Expand = 1:nrow( data ))
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{enter}] Date of entry into the study. Numerical vector.
\item[\code{exit}] Date of exit from the study. Numerical vector.
\item[\code{fail}] Failure indicator for the exit date.
\item[\code{dof}] Failure time(s). For multiple failures per individual,
\code{dof} must be a list.
\item[\code{data}] Dataframe of variables to be carried over to the output.
\item[\code{Expand}] Variable identifying original records.
\end{ldescription}
\end{Arguments}
\begin{Value}
A dataframe with the same variables as in \code{data} preceded by the
variables:
\begin{ldescription}
\item[\code{Expand}] Identification of the rows from the input dataframe.
\item[\code{Enter}] Entry date for the interval.
\item[\code{Exit}] Exit date for the interval.
\item[\code{Fail}] Failure indicator for end of the current interval.
\item[\code{n.Fail}] Number of failures prior to the start of the current
interval. Counts all failures given in the list \code{dof},
including those prior to \code{enter}.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\email{bxc@steno.dk}, \url{www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},
\code{\LinkA{isec}{isec}},
\code{\LinkA{icut}{icut}},
\code{\LinkA{fcut1}{fcut1}},
\code{\LinkA{ex1}{ex1}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
one <- round( runif( 15, 0, 10 ), 1 )
two <- round( runif( 15, 0, 10 ), 1 )
doe <- pmin( one, two )
dox <- pmax( one, two )
# Goofy data rows to test possibly odd behaviour
doe[1:3] <- dox[1:3] <- 8
dox[2] <- 6
dox[3] <- 7.5
# Some failure indicators
fail <- sample( 0:1, 15, replace=TRUE, prob=c(0.7,0.3) )
# Failure times in a list
dof <- sample( c(one,two), 15 )
l.dof <- list( f1=sample( c(one,two), 15 ),
               f2=sample( c(one,two), 15 ),
               f3=sample( c(one,two),15 ) )
# The same, but with events prior to entry removed
lx.dof <- lapply( l.dof, FUN=function(x){ x[x<doe] <- NA ; x } )
# So what have we got
data.frame( doe, dox, fail, l.dof, lx.dof )
# Cut follow-up at event times
fcut( doe, dox, lx.dof, fail, data=data.frame( doe, dox, lx.dof ) )
\end{ExampleCode}
\end{Examples}

\HeaderA{fcut1}{Cut follow-up time at a failure time.}{fcut1}
\keyword{manip}{fcut1}
\keyword{datagen}{fcut1}
\begin{Description}\relax
This function cuts the follow-up time at a failure allowing a person
to stay at risk after the failure. It is aimed at processing of
recurrent events. Failure times outside the interval
(\code{enter},\code{exit}) are ignored.
\end{Description}
\begin{Usage}
\begin{verbatim}
fcut1( enter, exit, fail, dof, fail.value = 1, 
         data = data.frame(enter, exit, fail, dof),
       Expand = 1:nrow(data) )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{enter}] Date of entry into the study. Numerical vector.
\item[\code{exit}] Date of exit from the study. Numerical vector.
\item[\code{fail}] Failure indicator for the exit date.
\item[\code{dof}] Date of failure. Numerical vector. Missing for persons who
do not have an event.
\item[\code{fail.value}] Value for failure indicator \code{Fail} at the date
\code{dof}.
\item[\code{data}] Dataframe of variables to be carried unchanged to the
output.
\item[\code{Expand}] Variable identifying original records.
\end{ldescription}
\end{Arguments}
\begin{Value}
A dataframe with the same columns as in \code{data}, preceded by the columns:
\begin{ldescription}
\item[\code{Expand}] Identification of the rows from the input dataframe.
\item[\code{Enter}] Entry date for the interval.
\item[\code{Exit}] Exit date for the interval.
\item[\code{Fail}] Failure indicator for the interval.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\email{bxc@steno.dk}, \url{www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},
\code{\LinkA{isec}{isec}},
\code{\LinkA{fcut1}{fcut1}},
\code{\LinkA{fcut}{fcut}},
\code{\LinkA{ex1}{ex1}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
one <- round( runif( 15, 0, 10 ), 1 )
two <- round( runif( 15, 0, 10 ), 1 )
doe <- pmin( one, two )
dox <- pmax( one, two )
# Goofy data rows to test possibly odd behaviour
doe[1:3] <- dox[1:3] <- 8
dox[2] <- 6
dox[3] <- 7.5
# Some failure indicators and failure times
fail <- sample( 0:1, 15, replace=TRUE, prob=c(0.7,0.3) )
dof <- sample( c(one,two), 15 )
# So what have we got
data.frame( doe, dox, fail, dof )
# Cut follow-up at dof
fcut1( doe, dox, fail, dof )
\end{ExampleCode}
\end{Examples}

\HeaderA{fit.add}{Fit an addive excess risk model to interval censored data.}{fit.add}
\keyword{models}{fit.add}
\keyword{regression}{fit.add}
\keyword{survival}{fit.add}
\begin{Description}\relax
Utility function.

The model fitted assumes a piecewise constant inensity for the
baseline, and that the covariates act additively on the rate scale.
\end{Description}
\begin{Usage}
\begin{verbatim}
  fit.add( y, rates.frame, cov.frame, start )
  \end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] Binary vector of outcomes
\item[\code{rates.frame}] Dataframe expanded from the original data by
\code{\LinkA{expand.data}{expand.data}}, cooresponding to covariates for the rate
parameters.
\item[\code{cov.frame}] do., but covariates corresponding to the
\code{formula} argument of \code{\LinkA{Icens}{Icens}}
\item[\code{start}] Starting values for the rate parameters. If not supplied,
then starting values are generated.
\end{ldescription}
\end{Arguments}
\begin{Value}
A \code{\LinkA{glm}{glm}} object from a binomial model with log-link function.
\end{Value}
\begin{Author}\relax
Martyn Plummer, \email{plummer@iarc.fr}
\end{Author}
\begin{References}\relax
B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.

CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Icens}{Icens}}
\code{\LinkA{fit.mult}{fit.mult}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
  data( HIV.dk ) 
  \end{ExampleCode}
\end{Examples}

\HeaderA{fit.baseline}{Fit a piecewise contsnt intesity model for interval censored data.}{fit.baseline}
\keyword{models}{fit.baseline}
\keyword{regression}{fit.baseline}
\keyword{survival}{fit.baseline}
\begin{Description}\relax
Utility function

Fits a binomial model with logaritmic link, with \code{y} as outcome
and covariates in \code{rates.frame} to estimate rates in the
inttervals between \code{breaks}.
\end{Description}
\begin{Usage}
\begin{verbatim}
fit.baseline( y, rates.frame, start )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] Binary vector of outcomes
\item[\code{rates.frame}] Dataframe expanded from the original data by
\code{\LinkA{expand.data}{expand.data}}
\item[\code{start}] Starting values for the rate parameters. If not supplied,
then starting values are generated.
\end{ldescription}
\end{Arguments}
\begin{Value}
A \code{\LinkA{glm}{glm}} object, with binomial error and logaritmic link.
\end{Value}
\begin{Author}\relax
Martyn Plummer, \email{plummer@iarc.fr}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{fit.add}{fit.add}}
\code{\LinkA{fit.mult}{fit.mult}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
  \end{ExampleCode}
\end{Examples}

\HeaderA{fit.mult}{Fits a multiplicative relative risk model to interval censored data.}{fit.mult}
\keyword{models}{fit.mult}
\keyword{regression}{fit.mult}
\keyword{survival}{fit.mult}
\begin{Description}\relax
Utility function.

The model fitted assumes a piecewise constant baseline rate in
intervals specified by the argument \code{breaks}, and a
multiplicative relative risk function.
\end{Description}
\begin{Usage}
\begin{verbatim}
  fit.mult( y, rates.frame, cov.frame, start )
  \end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] Binary vector of outcomes
\item[\code{rates.frame}] Dataframe expanded from the original data by
\code{\LinkA{expand.data}{expand.data}}, cooresponding to covariates for the rate
parameters.
\item[\code{cov.frame}] do., but covariates corresponding to the
\code{formula} argument of \code{\LinkA{Icens}{Icens}}
\item[\code{start}] Starting values for the rate parameters. If not supplied,
then starting values are generated.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The model is fitted by alternating between two generalized linear
models where one estimates the underlying rates in the intervals, and
the other estimates the log-relative risks.
\end{Details}
\begin{Value}
A list with three components:
\begin{ldescription}
\item[\code{rates}] A glm object from a binomial model with log-link,
estimating the baseline rates.
\item[\code{cov}] A glm object from a binomial model with complementary
log-log link, estimating the log-rate-ratios
\item[\code{niter}] Nuber of iterations, a scalar
\end{ldescription}
\end{Value}
\begin{Author}\relax
Martyn Plummer, \email{plummer@iarc.fr},
Bendix Carstensen, \email{bxc@steno.dk}
\end{Author}
\begin{References}\relax
B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.

CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Icens}{Icens}}
\code{\LinkA{fit.add}{fit.add}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
  data( HIV.dk ) 
  \end{ExampleCode}
\end{Examples}

\HeaderA{float}{Calculate floated variances}{float}
\aliasA{print.floated}{float}{print.floated}
\keyword{regression}{float}
\begin{Description}\relax
Given a fitted  model object, the \code{float()} function calculates
floating variances (aka quasi-variances) for a given factor in the model.
\end{Description}
\begin{Usage}
\begin{verbatim}
float(object, factor, iter.max=50)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] a fitted model object
\item[\code{factor}] character string giving the name of the factor of
interest. If this is not given, the first factor in the model is used.
\item[\code{iter.max}] Maximum number of iterations for EM algorithm
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
float() implements the "floating absolute risk" proposal of Easton,
Peto and Babiker(1992). This is an alternative way of presenting
parameter estimates for factors in regression models, which avoids
some of the difficulties of treatment contrasts. It was originally
designed for epidemiological studies of relative risk (hence the name)
but the idea is widely applicable.  

A problem with treatment contrasts is that they are not
orthogonal. The variances of the treatment contrasts may be inflated by
a poor choice of reference level, and the correlations between them
may be very high.  float() associates each level of the factor,
including the reference level, with a"floating" variance (or
quasi-variance). Floating variances are not real variances, but
they can be used to calculate the variance of any contrast by treating
each level as independent.

Plummer (2003) showed that floating variances can be derived from a
covariance structure model applied to the variance-covariance
matrix of the parameter estimates. This model can be fitted by
minimizing the Kullback-Leibler information divergence between the
true and distributions for the parameter estimates and the
distribution given by the covariance structure model. Fitting is
done using the EM algorithm.

In order to check the goodness-of-fit of the floating variance
model, \code{float()} compares the standard errors predicted
by the model with the standard errors derived from the true
variance-covariance matrix of the parameter contrasts. The maximum
and minimum ratios between true and model standard errors are
calculated over all possible contrasts. These should be within 5
percent, or the use of the floating variances may lead to invalid
confidence intervals.
\end{Details}
\begin{Value}
An object of class \code{floated}. This is a list with the following
components
\begin{ldescription}
\item[\code{coef}] vector of coefficients. These are the same as the
treatment contrasts but the reference level is present with
coefficient 0.
\item[\code{var}] vector of floating (or quasi-) variances
\item[\code{limits}] Bounds on the accuracy of standard errors over all
possible contrasts
\end{ldescription}
\end{Value}
\begin{Note}\relax
Menezes(1999) and Firth and Menezes (2004) take a slightly different
approach to this problem, using a pseudo-likelihood approach to fit
the quasi-variance model. Their work is implemented in the package qvcalc.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{References}\relax
Easton DF, Peto J and Babiker GAG (1991) Floating absolute risk: An
alternative to relative risk in survival and case control analysis
avoiding an arbitrary reference group. \emph{Statistics in Medicine},
\bold{10}, 1025-1035.

Firth D and Mezezes RX (2004)  Quasi-variances.
\emph{Biometrika} \bold{91}, 65-80.

Menezes RX(1999)  More useful standard errors for group and factor
effects in generalized linear models.  \emph{D.Phil. Thesis},
Department of Statistics, University of Oxford.

Plummer M (2003) Improved estimates of floating absolute risk,
\emph{Statistics in Medicine}, \bold{23}, 93-104.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{ftrend}{ftrend}}, \code{qvcalc}
\end{SeeAlso}

\HeaderA{ftrend}{Fit a floating trend to a factor in generalized linear model}{ftrend}
\keyword{regression}{ftrend}
\begin{Description}\relax
Fits a "floating trend" model to the given factor in a glm in a generalized
linear model by centering covariates.
\end{Description}
\begin{Usage}
\begin{verbatim}
ftrend(object, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] fitted \code{lm} or \code{glm} object. The model must not have an intercept term
\item[\code{...}] arguments to the \code{nlm} function
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
\code{ftrend()} calculates "floating trend" estimates for factors in
generalized linear models.  This is an alternative to treatment
contrasts suggested by Greenland et al. (1999).  If a regression model
is fitted with no intercept term, then contrasts are  not used for the
first factor in the model. Instead, there is one parameter  for each
level of this factor.  However, the interpretation of these
parameters,  and their variance-covariance matrix, depends on the
numerical coding used for the  covariates. If an arbitrary constant is
added to the covariate values, then   the variance matrix is changed. 

The \code{ftrend()} function takes the fitted model and works out an optimal 
constant to add to the covariate values so that the covariance matrix is
approximately diagonal.  The parameter estimates can then be treated as
approximately independent, thus simplifying their presentation. This is
particularly useful for graphical display of dose-response relationships
(hence the name).

Greenland et al. (1999) originally suggested centring the covariates so that
their weighted mean, using the fitted weights from the model, is zero.  This
heuristic criterion is improved upon by \code{ftrend()} which uses the same 
minimum information divergence criterion as used by Plummer (2003) for
floating variance calculations. \code{ftrend()} calls \code{nlm()} to
do the minimization and will pass optional arguments to control it.
\end{Details}
\begin{Value}
A list with the following components
\begin{ldescription}
\item[\code{coef}] coefficients for model with adjusted covariates.
\item[\code{vcov}] Variance-covariance matrix of adjusted coefficients.
\end{ldescription}
\end{Value}
\begin{Note}\relax
The "floating trend" method is an alternative to the "floating
absolute risk" method, which is implemented in the function
\code{float()}.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{References}\relax
Greenland S, Michels KB, Robins JM, Poole C and Willet WC (1999)
Presenting statistical uncertainty in trends and dose-response relations,
\emph{American Journal of Epidemiology}, \bold{149}, 1077-1086.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{float}{float}}
\end{SeeAlso}

\HeaderA{gmortDK}{Population mortality rates for Denmark in 5-years age groups.}{gmortDK}
\keyword{datasets}{gmortDK}
\begin{Description}\relax
The \code{gmortDK} data frame has 418 rows and 21 columns.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{agr}: & Age group, 0:0--4, 5:5--9,..., 90:90+. \\
\code{per}: & Calendar period, 38: 1938--42, 43: 1943--47, ..., 88:1988-92. \\
\code{sex}: & Sex, 1: male, 2: female. \\
\code{risk}: & Number of person-years in the Danish population. \\
\code{dt}: & Number of deaths. \\
\code{rt}: & Overall mortality rate in cases per 1000 person-years, i.e.
\code{rt=1000*dt/risk} \\
& Cause-specific mortality rates in cases per 1000 person-years: \\
\code{r1}: & Infections \\
\code{r2}: & Cancer. \\
\code{r3}: & Tumors, benign, unspecific nature. \\
\code{r4}: & Endocrine, metabolic. \\
\code{r5}: & Blood. \\
\code{r6}: & Nervous system, psychiatric. \\
\code{r7}: & Cerebrovascular. \\
\code{r8}: & Cardiac. \\
\code{r9}: & Respiratory diseases, excl. cancer. \\
\code{r10}: & Liver, excl. cancer. \\
\code{r11}: & Digestive, other. \\
\code{r12}: & Genitourinary. \\
\code{r13}: & Ill-defined symptoms. \\
\code{r14}: & All other, natural. \\
\code{r15}: & Violent. \\
}
\end{Format}
\begin{Source}\relax
Statistics Denmark, National board of health provided original data. 
Michael Andersson grouped the causes of death.
\end{Source}
\begin{SeeAlso}\relax
\code{\LinkA{thoro}{thoro}}, \code{\LinkA{mortDK}{mortDK}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data(gmortDK)
\end{ExampleCode}
\end{Examples}

\HeaderA{hivDK}{hivDK: seroconversion in a cohort of Danish men}{hivDK}
\keyword{datasets}{hivDK}
\begin{Description}\relax
Data from a survey of HIV-positivity of a cohort of Danish
men followed by regular tests from 1983 to 1989.
\end{Description}
\begin{Usage}
\begin{verbatim}
  data(hivDK)
  \end{verbatim}
\end{Usage}
\begin{Format}\relax
A data frame with 297 observations on the following 7 variables.
\describe{
\item[\code{id}] ID of the person
\item[\code{entry}] Date of entry to the study. Date variable.
\item[\code{well}] Date last seen seronegative. Date variable.
\item[\code{ill}] Date first seen seroconverted. Date variable.
\item[\code{bth}] Year of birth minus 1950.
\item[\code{pyr}] Annual number of sexual partners.
\item[\code{us}] Indicator of wheter the person has visited the USA.
}
\end{Format}
\begin{Source}\relax
Mads Melbye, Statens Seruminstitut.
\end{Source}
\begin{References}\relax
Becker N.G. and Melbye M.: Use of a log-linear model to
compute the empirical survival curve from interval-censored data,
with application to data on tests for HIV-positivity, Australian
Journal of Statistics, 33, 125--133, 1990.

Melbye M., Biggar R.J., Ebbesen P., Sarngadharan M.G., Weiss
S.H., Gallo R.C. and Blattner W.A.: Seroepidemiology of HTLV-III
antibody in Danish homosexual men: prevalence, transmission and
disease outcome. British Medical Journal, 289, 573--575, 1984.
\end{References}
\begin{Examples}
\begin{ExampleCode}
  data(hivDK)
  str(hivDK) 
  \end{ExampleCode}
\end{Examples}

\HeaderA{Icens}{Fits a regression model to interval censored data.}{Icens}
\aliasA{print.Icens}{Icens}{print.Icens}
\keyword{models}{Icens}
\keyword{regression}{Icens}
\keyword{survival}{Icens}
\begin{Description}\relax
The models fitted assumes a piecewise constant baseline rate in
intervals specified by the argument \code{breaks}, and for the
covariates either a multiplicative relative risk function (default) or
an additive excess risk function.
\end{Description}
\begin{Usage}
\begin{verbatim}
  Icens( first.well, last.well, first.ill,
         formula, model.type=c("MRR","AER"), breaks,
         boot=FALSE, alpha=0.05, keep.sample=FALSE,
         data )
  \end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{first.well}] Time of entry to the study, i.e. the time first seen
without event. Numerical vector.
\item[\code{last.well}] Time last seen without event. Numerical vector.
\item[\code{first.ill}] Time first seen with event. Numerical vector.
\item[\code{formula}] Model formula for the log relative risk.
\item[\code{model.type}] Which model should be fitted.
\item[\code{breaks}] Breakpoints between intervals in which the underlying
timescale is assumed constant. Any observation outside the range of
\code{breaks} is discarded.
\item[\code{boot}] Should bootstrap be performed to produce confidence
intervals for parameters. If a number is given this will be the
number of bootsrap samples. The default is 1000.
\item[\code{alpha}] 1 minus the confidence level.
\item[\code{keep.sample}] Should the bootstrap sample of the parameter values
be returned?
\item[\code{data}] Data frame in which the times and formula are interpreted.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The model is fitted by calling either \code{\LinkA{fit.mult}{fit.mult}} or
\code{\LinkA{fit.add}{fit.add}}.
\end{Details}
\begin{Value}
An object of class \code{"Icens"}: a list with three components:
\begin{ldescription}
\item[\code{rates}] A glm object from a binomial model with log-link,
estimating the baseline rates, and the excess risk if \code{"AER"}
is specfied.
\item[\code{cov}] A glm object from a binomial model with complementary
log-log link, estimating the log-rate-ratios. Only if \code{"MRR"}
is specfied.
\item[\code{niter}] Nuber of iterations, a scalar
\item[\code{boot.ci}] If \code{boot=TRUE}, a 3-column matrix with estimates
and 1-\code{alpha} confidence intervals for the parameters in the model.
\item[\code{sample}] A matrix of the parameterestimates from the
bootstrapping. Rows refer to parameters, columns to bootstrap samples.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Martyn Plummer, \email{plummer@iarc.fr},
Bendix Carstensen, \email{bxc@steno.dk}
\end{Author}
\begin{References}\relax
B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.

CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{fit.add}{fit.add}}
\code{\LinkA{fit.mult}{fit.mult}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data( hivDK )
# Convert the dates to fractional years so that rates are
# expressed in cases per year
for( i in 2:4 ) hivDK[,i] <- cal.yr( hivDK[,i] )

m.RR <- Icens( entry, well, ill,
               model="MRR", formula=~pyr+us, breaks=seq(1980,1990,5),
               data=hivDK)
# Currently the MRR model returns a list with 2 glm objects.
round( ci.lin( m.RR$rates ), 4 )
round( ci.lin( m.RR$cov, Exp=TRUE ), 4 )
# There is actually a print method:
print( m.RR )

m.ER <- Icens( entry, well, ill,
               model="AER", formula=~pyr+us, breaks=seq(1980,1990,5),
               data=hivDK)
# There is actually a print method:
print( m.ER )
  \end{ExampleCode}
\end{Examples}

\HeaderA{icut}{Function to cut the follow-up in cohort at a point in time.}{icut}
\keyword{manip}{icut}
\keyword{datagen}{icut}
\begin{Description}\relax
The follow up time from \code{enter} to \code{exit} is classified as
to wheter it is before \code{cut} (\code{Time}=0) or after
\code{Time}=1). If \code{cut} is between \code{enter} and \code{exit},
the follow-up is split in two intervals, the first gets the value
\code{cens} for the status.
\end{Description}
\begin{Usage}
\begin{verbatim}
icut( enter, exit, cut, fail = 0, cens.value = 0,
      data = data.frame(enter, exit, fail, cut),
      Expand = 1:nrow( data ),
      na.cut = Inf )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{enter}] Date of entry. Numerical vector.
\item[\code{exit}] Date of exit. Numerical vector.
\item[\code{fail}] Indicator if exit status.
\item[\code{cens.value}] Value to use for censoring status.
\item[\code{cut}] Date where to cut follow-up. Numerical vector.
\item[\code{data}] Dataframe of variables to carry over to the output dataframe.
\item[\code{Expand}] Variable identifying original records.
\item[\code{na.cut}] What value should be assigned to missing values of the
cutpoint. Defaults to \code{Inf}, so the inetrmediate event is
considered not to have occcurred. If set to \code{-Inf}, all persons
with missing \code{cut} are considered to have had an intermediate
event. If set to \code{NA} records with missing \code{cut} are
omitted from the result.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The purpose of this function is to divide follow-up into pre- and post
some intermediate event like recurrence of disease, thus enabling
Follow-up for persons with a recurrence date (\code{cut}) will be
split in two, with indication (in \code{Time}) of what is pre and what
is post recurrence. This is typically what precedes a survival
analysis where recurrence is modelled as a time-dependent variable.
\end{Details}
\begin{Value}
A data frame with one row per interval of follow up and columns given
in the \code{data} argument, preceded by the columns:
\begin{ldescription}
\item[\code{Expand}] Identification of the rows from the input dataframe.
\item[\code{Enter}] Entry date for the interval.
\item[\code{Exit}] Exit date for the interval.
\item[\code{Fail}] Failure indicator for the interval.
\item[\code{Time}] Indicator variable for intervals after \code{cut}.
\end{ldescription}
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\email{bxc@steno.dk}, \url{www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},
\code{\LinkA{isec}{isec}},
\code{\LinkA{fcut1}{fcut1}},
\code{\LinkA{fcut}{fcut}},
\code{\LinkA{ex1}{ex1}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
one <- round( runif( 15, 0, 15 ), 1 )
two <- round( runif( 15, 0, 15 ), 1 )
doe <- pmin( one, two )
dox <- pmax( one, two )
# Goofy data rows to test possibly odd behaviour
doe[1:3] <- dox[1:3] <- 8
dox[2] <- 6
dox[3] <- 7.5
# Some failure indicators
fail <- sample( 0:1, 15, replace=TRUE, prob=c(0.7,0.3) )
# So what have we got
data.frame( doe, dox, fail )
# Cut follow-up at 5
icut( doe, dox, fail, cut=5 )
\end{ExampleCode}
\end{Examples}

\HeaderA{isec}{Determine the intersection between follow-up intervals and a fixed
interval.}{isec}
\keyword{manip}{isec}
\keyword{datagen}{isec}
\begin{Description}\relax
For a given piece of follow-up for ach person, this function determines
the part of the follow-up which is inside a pre-specified interval. The
function may occasionally be useful but is mainly included as a tool to
be used in the function \code{\LinkA{Lexis}{Lexis}}.
\end{Description}
\begin{Usage}
\begin{verbatim}
  isec( enter, exit, fail = 0, int, cens.value = 0,
        Expand = 1:length(enter))
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{enter}] Numereical vector of entry times.
\item[\code{exit}] Numerical vector of exit times.
\item[\code{fail}] Vector of exit status, i.e. status at time \code{exit}
\item[\code{int}] The fixed interval. Numerical vector of length 2.
\item[\code{cens.value}] Censoring value. Numerical. If the person survives the fixed
interval, this will be the value of the status indicator, \code{Fail}
\item[\code{Expand}] Person id to be carried to the output
\end{ldescription}
\end{Arguments}
\begin{Value}
A matrix with columns \code{Expand} - person identification,
\code{Enter} - date of entry into the interval, \code{Exit} - date of exit
from the interval and \code{Fail}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\email{bxc@steno.dk}, \url{www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},
\code{\LinkA{icut}{icut}},
\code{\LinkA{fcut1}{fcut1}},
\code{\LinkA{fcut}{fcut}},
\code{\LinkA{ex1}{ex1}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
one <- round( runif( 15, 0, 15 ), 1 )
two <- round( runif( 15, 0, 15 ), 1 )
doe <- pmin( one, two )
dox <- pmax( one, two )
# Goofy data rows to test possibly odd behaviour
doe[1:3] <- dox[1:3] <- 8
dox[2] <- 6
dox[3] <- 7.5
# Some failure indicators
fail <- sample( 0:1, 15, replace=TRUE, prob=c(0.7,0.3) )
# So what have we got?
data.frame( doe, dox, fail )
# Find intersection with interval (4,8)
isec( doe, dox, fail, int=c(4,8) )
# See how it compares to original data
merge( data.frame( Expand=1:15, doe, dox, fail ),
       data.frame( isec( doe, dox, fail, int=c(4,8) ) ), all=TRUE )
  \end{ExampleCode}
\end{Examples}

\HeaderA{lep}{An unmatched case-control study of leprosy incidence}{lep}
\keyword{datasets}{lep}
\begin{Description}\relax
The \code{lep} data frame has 1370 rows and 7 columns. This was an
unmatched case-control study in which incident cases of leprosy in a
region of N. Malawi were compared with population controls.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{id}: & subject identifier: a numeric vector \\
\code{d}: & case/control status: a numeric vector (1=case, 0=control) \\

\code{age}: & a factor with levels
\code{5-9} 
\code{10-14} 
\code{15-19} 
\code{20-24} 
\code{25-29} 
\code{30-44} 
\code{45+}  \\

\code{sex}: & a factor with levels
\code{male},  
\code{female}  \\ 

\code{bcg}: & presence of vaccine scar, a factor with levels
\code{no} 
\code{yes}  \\

\code{school}: & schooling, a factor with levels
\code{none} 
\code{1-5yrs} 
\code{6-8yrs} 
\code{sec/tert} \\

\code{house}: & housing, a factor with levels
\code{brick} 
\code{sunbrick} 
\code{wattle} 
\code{temp}  \\
}
\end{Format}
\begin{Source}\relax
The study is described in more detail in Clayton and Hills, Statistical
Models in Epidemiology, Oxford University Press, Oxford:1993.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(lep)
\end{ExampleCode}
\end{Examples}

\HeaderA{Lexis.diagram}{Plot a Lexis diagram}{Lexis.diagram}
\keyword{hplot}{Lexis.diagram}
\keyword{dplot}{Lexis.diagram}
\begin{Description}\relax
Draws a Lexis diagram, optionally with life lines from a cohort, and
with lifelines of a cohort if supplied.
\end{Description}
\begin{Usage}
\begin{verbatim}
Lexis.diagram( age = c( 0, 60), 
              alab = "Age",
              date = c( 1940, 2000 ),
              dlab = "Calendar time",
               int = 5,
           lab.int = 2*int, 
          col.life = "black",
          lwd.life = 2,
          age.grid = TRUE,
         date.grid = TRUE,
          coh.grid = FALSE,
          col.grid = gray(0.7),
          lwd.grid = 1,     
               las = 1,
        entry.date = NA,
         entry.age = NA,
         exit.date = NA,
          exit.age = NA,
         risk.time = NA,
        birth.date = NA,
              fail = NA,
          cex.fail = 1.1, 
          pch.fail = c(NA,16),
          col.fail = rep( col.life, 2 ),
              data = NULL, ... )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{age}] Numerical vector of length 2, giving the age-range for the diagram
\item[\code{alab}] Label on the age-axis.
\item[\code{date}] Numerical vector of length 2, giving the calendar
time-range for the diagram
\item[\code{dlab}] label on the calendar time axis.
\item[\code{int}] The interval between grid lines in the diagram. If a
vector of length two is given, the first value will be used for
spacing of age-grid and the second for spacing of the date grid.
\item[\code{lab.int}] The interval between labelling of the grids.
\item[\code{col.life}] Colour of the life lines.
\item[\code{lwd.life}] Width of the life lines.
\item[\code{age.grid}] Should grid lines be drawn for age?
\item[\code{date.grid}] Should grid lines be drawn for date?
\item[\code{coh.grid}] Should grid lines be drawn for birth cohorts (diagonals)?
\item[\code{col.grid}] Colour of the grid lines.
\item[\code{lwd.grid}] Width of the grid lines.
\item[\code{las}] How are the axis labels plotted?
\item[\code{entry.date, entry.age, exit.date, exit.age, risk.time,
birth.date}] Numerical vectors defining lifelines to be plotted
in the diagram. At least three must be given to produce lines.
Not all subsets of three will suffice, the given subset has to 
define life lines.
If insufficient data is given, no life
lines are produced.
\item[\code{fail}] Logical of event status at exit for the persons whose 
life lines are plotted.
\item[\code{pch.fail}] Symbols at the end of the life lines for censorings
(\code{fail}=0) and failures (\code{fail}$\ne$0).
\item[\code{cex.fail}] Expansion of the status marks at the end of life lines.
\item[\code{col.fail}] Character vector of length 2 giving the colour of the
failure marks for censorings and failures respectively.
\item[\code{data}] Dataframe in which to interpret the arguments.
\item[\code{...}] Arguments to be passed on to the initial call to plot.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The default unit for supplied variables are (calendar) years.
If any of the variables \code{entry.date}, \code{exit.date} or
\code{birth.date} are of class "\code{Date}" or if any of the variables
\code{entry.age}, \code{exit.age} or \code{risk.time} are of class
"\code{difftime}", they will be converted to calendar years, and plotted
correctly in the diagram. The returned dataframe will then have colums of
classes "\code{Date}" and  "\code{difftime}".
\end{Details}
\begin{Value}
If sufficient information on lifelines is given, a data frame with
one row per person and columns with entry ages and dates, birth date,
risk time and status filled in.

Side effect: a plot of a Lexis diagram is produced with the life lines
in it is produced. This will be the main reason for using the
function.
\end{Value}
\begin{Author}\relax
Bendix Carstensen,
\url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Life.lines}{Life.lines}},
\code{\LinkA{Lexis.lines}{Lexis.lines}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
Lexis.diagram( entry.age = c(3,30,45),
               risk.time = c(25,5,14),
              birth.date = c(1970,1931,1925.7),
                    fail = c(TRUE,TRUE,FALSE) )
LL <- Lexis.diagram( entry.age = sample( 0:50, 17, replace=TRUE ),
                     risk.time = sample( 5:40, 17, r=TRUE),
                    birth.date = sample( 1910:1980, 17, r=TRUE ),
                          fail = sample( 0:1, 17, r=TRUE ), 
                      cex.fail = 1.1,
                      lwd.life = 2 )
# Identify the persons' entry and exits
text( LL$exit.date, LL$exit.age, paste(1:nrow(LL)), col="red", font=2, adj=c(0,1) )
text( LL$entry.date, LL$entry.age, paste(1:nrow(LL)), col="blue", font=2, adj=c(1,0) )
data( nickel )
attach( nickel )
LL <- Lexis.diagram( age=c(10,100), date=c(1900,1990), 
                     entry.age=age1st, exit.age=ageout, birth.date=dob, 
                     fail=(icd %in% c(162,163)), lwd.life=1,
                     cex.fail=0.8, col.fail=c("green","red") )
abline( v=1934, col="blue" )
nickel[1:10,]
LL[1:10,]
\end{ExampleCode}
\end{Examples}

\HeaderA{Lexis.lines}{Draw life lines in a Lexis diagram.}{Lexis.lines}
\keyword{hplot}{Lexis.lines}
\keyword{dplot}{Lexis.lines}
\begin{Description}\relax
Add life lines to a Lexis diagram.
\end{Description}
\begin{Usage}
\begin{verbatim}
Lexis.lines( entry.date = NA,
              exit.date = NA,
             birth.date = NA,
              entry.age = NA,
               exit.age = NA,
              risk.time = NA,
               col.life = "black",
               lwd.life = 2,
                   fail = NA,
               cex.fail = 1,
               pch.fail = c(NA, 16),
               col.fail = col.life,
                   data = NULL )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{entry.date, entry.age, exit.date, exit.age, risk.time,
birth.date}] Numerical vectors defining lifelines to be plotted
in the diagram. At least three must be given to produce lines.
Not all subsets of three will suffice, the given subset has to 
define life lines. If insufficient data is given, no life
lines are produced.
\item[\code{col.life}] Colour of the life lines.
\item[\code{lwd.life}] Width of the life lines.
\item[\code{fail}] Logical of event status at exit for the persons whose 
life lines are plotted.
\item[\code{cex.fail}] The size of the status marks at the end of life lines.
\item[\code{pch.fail}] The status marks at the end of the life lines.
\item[\code{col.fail}] Colour of the marks for censorings and failures
respectively.
\item[\code{data}] Data frame in which to interpret values.
\end{ldescription}
\end{Arguments}
\begin{Value}
If sufficient information on lifelines is given, a data frame with one
row per person and columns with entry ages and dates, birth date, risk
time and status filled in.

Side effect: Life lines are added to an existing Lexis
diagram. Lexis.lines adds life lines to an existing plot.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis.diagram}{Lexis.diagram}},
\code{\LinkA{Life.lines}{Life.lines}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
Lexis.diagram( entry.age = c(3,30,45),
               risk.time = c(25,5,14),
              birth.date = c(1970,1931,1925.7),
                    fail = c(TRUE,TRUE,FALSE) )
Lexis.lines( entry.age = sample( 0:50, 100, replace=TRUE ),
             risk.time = sample( 5:40, 100, r=TRUE),
            birth.date = sample( 1910:1980, 100, r=TRUE ),
                  fail = sample(0:1,100,r=TRUE),
              cex.fail = 0.5,
              lwd.life = 1 )
\end{ExampleCode}
\end{Examples}

\HeaderA{Lexis}{Create a Lexis object}{Lexis}
\keyword{survival}{Lexis}
\begin{Description}\relax
Create an object of class \code{Lexis} to represent follow-up on
multiple time scales.
\end{Description}
\begin{Usage}
\begin{verbatim}
Lexis(entry, exit, duration, entry.status = 0, exit.status = 0, id, data,
      merge=TRUE)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{entry}] a named list of entry times. Each element of the list is
a numeric variable representing the entry time on the named time
scale. All time scales must have the same units (e.g. years)
\item[\code{exit}] a named list of exit times
\item[\code{duration}] a numeric vector giving the duration of follow-up
\item[\code{entry.status}] a vector giving the status at entry
\item[\code{exit.status}] a vector giving status at exit. Any change in
status during follow-up is assumed to take place exactly at the exit time
\item[\code{id}] a vector giving a unique identity value for each row of the
Lexis object
\item[\code{data}] an optional data frame, list, or environment containing
the variables. If  not found in \code{data}, the variables are
taken from the environment from which \code{Lexis} was called
\item[\code{merge}] a logical flag. If \code{TRUE} then the \code{data} 
argument will be coerced to a data frame and then merged with
the resulting \code{Lexis} object
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The analysis of long-term population-based follow-up studies typically
requires multiple time scales to be taken into account, such as
age, calender time, or time since an event. A \code{Lexis} object is
a data frame with additional attributes that allows these multiple time
dimensions of follow-up to be managed.

Lexis objects are named after the German gemographer Wilhelm
Lexis (1837-1914), who is credited with the invention of the
"Lexis diagram" for representing population dynamics simultaneously
by age, period and cohort.

The \code{Lexis} function creates a minimal \code{Lexis} object with
only those variables required to define the follow-up history in each
row. Additional variables can be merged into the \code{Lexis} object
using the \code{merge} method for \code{Lexis} objects.
\end{Details}
\begin{Value}
An object of class \code{Lexis}. This is represented as a data frame
with a column for each time scale, and additional columns with the
following names:
\begin{ldescription}
\item[\code{lex.id}] Identification of the inidvidual
\item[\code{lex.deltat}] Duration of follow-up
\item[\code{lex.status1}] Entry status
\item[\code{lex.status2}] Exit status
\end{ldescription}

If \code{merge=TRUE} then the \code{Lexis} object will also contain
all variables from the \code{data} argument.
\end{Value}
\begin{Note}\relax
Only two of the three arguments \code{entry}, \code{exit} and
\code{duration} need to be given.  If the third parameter is missing,
it is imputed. If duration is imputed, it must be the same on
all time scales.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{plot.Lexis}{plot.Lexis}}, \code{\LinkA{splitLexis}{splitLexis}},
\code{\LinkA{merge.Lexis}{merge.Lexis}}, \code{\LinkA{entry}{entry}},
\code{\LinkA{timeScales}{timeScales}},
\code{\LinkA{timeBand}{timeBand}}
\end{SeeAlso}

\HeaderA{Life.lines}{Compute dates/ages for life lines in a Lexis diagram}{Life.lines}
\keyword{manip}{Life.lines}
\keyword{dplot}{Life.lines}
\begin{Description}\relax
Fills out the missing information for follow up of persons in a Lexis
diagram if sufficient information is given.
\end{Description}
\begin{Usage}
\begin{verbatim}
Life.lines( entry.date = NA,
             exit.date = NA,
            birth.date = NA,
             entry.age = NA,
              exit.age = NA,
             risk.time = NA )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{entry.date, exit.date,birth.date, entry.age, exit.age,
risk.time}] Vectors defining lifelines to be plotted 
in the diagram. At least three must be given to produce a result.
Not all subsets of three will suffice, the given subset has to 
define life lines. If insufficient data is given, nothing is
returned and a warning is given.
\end{ldescription}
\end{Arguments}
\begin{Value}
Data frame with variables \code{entry.date}, \code{entry.age},
\code{exit.date}, \code{exit.age}, \code{risk.time},
\code{birth.date}, with all entries computed for each person. If any
of \code{entry.date}, \code{exit.date} or \code{birth.date} are of
class \code{Date} or if any of \code{entry.age}, \code{exit.age} or
\code{risk.time} are of class \code{difftime} the date variables will
be of class  \code{Date} and the other three of class
\code{difftime}.
\end{Value}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis.diagram}{Lexis.diagram}},
\code{\LinkA{Lexis.lines}{Lexis.lines}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
( Life.lines( entry.age = c(3,30,45),
              risk.time = c(25,5,14),
             birth.date = c(1970,1931,1925.7) ) )

# Draw a Lexis diagram
Lexis.diagram()

# Compute entry and exit age and date.
( LL <-  Life.lines( entry.age = c(3,30,45),
                     risk.time = c(25,5,14),
                    birth.date = c(1970,1931,1925.7) ) )
segments( LL[,1], LL[,2], LL[,3], LL[,4] ) # Plot the life lines.

# Compute entry and exit age and date, supplying a date variable
bd <- ( c(1970,1931,1925.7) - 1970 ) * 365.25
class( bd ) <- "Date"
( Life.lines( entry.age = c(3,30,45),
              risk.time = c(25,5,14),
             birth.date = bd ) )
\end{ExampleCode}
\end{Examples}

\HeaderA{lungDK}{Male lung cancer incidence in Denmark}{lungDK}
\keyword{datasets}{lungDK}
\begin{Description}\relax
Male lung cancer cases and population riks time in Denmark, for the
period 1943--1992 in ages 40--89.
\end{Description}
\begin{Usage}
\begin{verbatim}data(lungDK)\end{verbatim}
\end{Usage}
\begin{Format}\relax
A data frame with 220 observations on the following 9 variables.
\Tabular{rl}{
\code{A5}: & Left end point of the age interval, a numeric vector. \\
\code{P5}: & Left enpoint of the period interval, a numeric vector. \\
\code{C5}: & Left enpoint of the birth cohort interval, a numeric vector. \\
\code{up}: & Indicator of upper trianges of each age by period
rectangle in the Lexis diagram. (\code{up=(P5-A5-C5)/5}). \\
\code{Ax}: & The mean age of diagnois (at risk) in the triangle. \\
\code{Px}: & The mean date of diagnosis (at risk) in the triangle. \\
\code{Cx}: & The mean date of birth in the triangle, a numeric vector. \\
\code{D}: & Number of diagnosed cases of male lung cancer. \\
\code{Y}: & Risk time in the male population, person-years. \\
}
\end{Format}
\begin{Details}\relax
Cases and person-years are tabulated by age and date of
diagnosis (period) as well as date of birth (cohort) in 5-year
classes. Each observation in the dataframe correponds to a triangle in
a Lexis diagram. Triangles are classified by age and date of
diagnosis, period of diagnosis and date of birth, all in 5-year
groupings.
\end{Details}
\begin{Source}\relax
The Danish Cancer Registry and Statistics Denmark.
\end{Source}
\begin{References}\relax
For a more thorough exposition of statistical inference in the Lexis
diagram, see: \url{http://staff.pubhealth.ku.dk/~bxc/APC/notes.pdf}
\end{References}
\begin{Examples}
\begin{ExampleCode}
data( lungDK )
# Draw a Lexis diagram and show the number of cases in it.
attach( lungDK )
Lexis.diagram( age=c(40,90), date=c(1943,1993), coh.grid=TRUE )
text( Px, Ax, paste( D ), cex=0.7 )
\end{ExampleCode}
\end{Examples}

\HeaderA{merge.data.frame}{Merge data frame with a Lexis object}{merge.data.frame}
\keyword{ts}{merge.data.frame}
\begin{Description}\relax
Merge two data frames, or a data frame with a \code{Lexis} object.
\end{Description}
\begin{Usage}
\begin{verbatim}
## S3 method for class 'data.frame':
merge(x, y, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x, y}] data frames, or objects to be coerced into one
\item[\code{...}] optional arguments for the merge method
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
This version of \code{merge.default} masks the one in the \code{base}.
It ensures that, if either \code{x} or \code{y} is a \code{Lexis}
object, then \code{merge.Lexis} is called.
\end{Details}
\begin{Value}
A merged \code{Lexis} object or data frame.
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}
\end{SeeAlso}

\HeaderA{merge.Lexis}{Merge a Lexis object with a data frame}{merge.Lexis}
\keyword{array}{merge.Lexis}
\keyword{manip}{merge.Lexis}
\begin{Description}\relax
Merge additional variables from a data frame into a Lexis object.
\end{Description}
\begin{Usage}
\begin{verbatim}
## S3 method for class 'Lexis':
merge(x, y, id, by, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an object of class \code{Lexis}
\item[\code{y}] a data frame
\item[\code{id}] the name of the variable in \code{y} to use for matching
against the variable \code{lex.id} in \code{x}.

\item[\code{by}] if matching is not done by id, a vector of variable names
common to both \code{x} and \code{y}
\item[\code{...}] optional arguments to be passed to \code{merge.data.frame}
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
A \code{Lexis} object can be considered as an augmented data frame
in which some variables are time-dependent variables representing
follow-up. The \code{Lexis} function produces a minimal object
containing only these time-dependent variables.  Additional variables
may be added to a \code{Lexis} object using the \code{merge} method.
\end{Details}
\begin{Value}
A \code{Lexis} object with additional columns taken from the
merged data frame.
\end{Value}
\begin{Note}\relax
The variable given as the \code{by.y} argument must not contain
any duplicate values in the data frame \code{y}.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{merge.data.frame}{merge.data.frame}}, \code{\LinkA{subset.Lexis}{subset.Lexis}}
\end{SeeAlso}

\HeaderA{mh}{Mantel-Haenszel analyses of cohort and case-control studies}{mh}
\keyword{htest}{mh}
\begin{Description}\relax
This function carries out Mantel-Haenszel comparisons in tabulated data 
derived from both cohort and case-control studies. Multiway tables of data
are accepted and any two levels of any dimension can be chosen as defining
the comparison groups. The rate (odds) ratio estimates and the associated
significance tests may be collapsed over all the remaining dimensions of the 
table, or over selected dimensions only (so that tables of estimates and 
tests are computed).
\end{Description}
\begin{Usage}
\begin{verbatim}
mh(cases, denom, compare=1, levels=c(1, 2), by=NULL,
     cohort=!is.integer(denom), confidence=0.9)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{cases}] the table of case frequencies (a multiway array).

\item[\code{denom}] the denominator table. For cohort studies this should be a table of 
person-years observation, while for case-control studies it should be a 
table of control frequencies. 

\item[\code{compare}] the dimension of the table which defines the comparison groups (can be 
referred to either by number or by name). The default is the first 
dimension of the table.

\item[\code{levels}] a vector identifying (either by number or by name) the two groups to be 
compared. The default is the first two levels of the selected dimension.

\item[\code{by}] the dimensions not to be collapsed in the Mantel-Haenszel computations. 
Thus, this argument defines the structure of the resulting tables of
estimates and tests.  

\item[\code{cohort}] an indicator  whether the data derive from a cohort or a case-control 
study. If the denominator table is stored as an integer, a case-control
study is assumed.

\item[\code{confidence}] the approximate coverage probability for the confidence intervals to be 
computed.

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
\end{Details}
\begin{Value}
A list giving tables of rate (odds) ratio estimates, their standard errors 
(on a log scale), lower and upper confidence limits, chi-squared tests 
(1 degree of freedom) and the corresponding p-values. The result list also 
includes numerator and denominator of the Mantel-Haenszel estimates (q, r), 
and score test statistics and score variance (u, v).
\end{Value}
\begin{Section}{Side Effects}
None
\end{Section}
\begin{References}\relax
Clayton, D. and Hills, M. : Statistical Models in Epidemiology, Oxford 
University Press (1993).
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# If d and y are 3-way tables of cases and person-years 
# observation formed by tabulation by two confounders 
# (named "C1" and "C2") an exposure of interest ("E"), 
# the following command will calculate an overall 
# Mantel-Haenszel comparison of the first two exposure 
# groups.
#
# Generate some bogus data
dnam <- list( E=c("low","medium","high"), C1=letters[1:2], C2=LETTERS[1:4] )
d <- array( sample( 2:80, 24),
            dimnames=dnam, dim=sapply( dnam, length ) )
y <- array( abs( rnorm( 24, 227, 50 ) ),
            dimnames=dnam, dim=sapply( dnam, length ) )
mh(d, y, compare="E")
#
# Or, if exposure levels named "low" and "high" are to be 
# compared and these are not the first two levels of E :
#
mh(d, y, compare="E", levels=c("low", "high"))
#
# If we wish to carry out an analysis which controls for C1, 
# but examines the results at each level of C2:
#
mh(d, y, compare="E", by="C2")
#
# It is also possible to look at rate ratios for every 
# combination of C1 and C2 :
#
mh(d, y, compare="E", by=c("C1", "C2"))
#
# If dimensions and levels of the table are unnamed, they must 
# be referred to by number.
#
\end{ExampleCode}
\end{Examples}

\HeaderA{mortDK}{Population mortality rates for Denmark in 1-year age-classes.}{mortDK}
\keyword{datasets}{mortDK}
\begin{Description}\relax
The \code{mortDK} data frame has 1820 rows and 21 columns.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{age}: & Age class, 0--89, 90:90+. \\
\code{per}: & Calendar period, 38: 1938--42, 43: 1943--47, ..., 88:1988-92. \\
\code{sex}: & Sex, 1: male, 2: female. \\
\code{risk}: & Number of person-years in the Danish population. \\
\code{dt}: & Number of deaths. \\
\code{rt}: & Overall mortality rate in cases per 1000 person-years, i.e.
\code{rt=1000*dt/risk} \\
& Cause-specific mortality rates in cases per 1000 person-years: \\
\code{r1}: & Infections \\
\code{r2}: & Cancer. \\
\code{r3}: & Tumors, benign, unspecific nature. \\
\code{r4}: & Endocrine, metabolic. \\
\code{r5}: & Blood. \\
\code{r6}: & Nervous system, psychiatric. \\
\code{r7}: & Cerebrovascular. \\
\code{r8}: & Cardiac. \\
\code{r9}: & Respiratory diseases, excl. cancer. \\
\code{r10}: & Liver, excl. cancer. \\
\code{r11}: & Digestive, other. \\
\code{r12}: & Genitourinary. \\
\code{r13}: & Ill-defined symptoms. \\
\code{r14}: & All other, natural. \\
\code{r15}: & Violent. \\
}
\end{Format}
\begin{Source}\relax
Statistics Denmark, National board of health provided original data. 
Michael Andersson grouped the causes of death.
\end{Source}
\begin{SeeAlso}\relax
\code{\LinkA{thoro}{thoro}}, \code{\LinkA{gmortDK}{gmortDK}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data(mortDK)
\end{ExampleCode}
\end{Examples}

\HeaderA{ncut}{Function to group a variable in intervals.}{ncut}
\keyword{manip}{ncut}
\begin{Description}\relax
Cuts a continuous variable in intervals. As opposed to \code{cut}
which returns a factor, \code{ncut} returns a numeric variable.
\end{Description}
\begin{Usage}
\begin{verbatim}
ncut(x, breaks, type="left" )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numerical vector.
\item[\code{breaks}] Vector of breakpoints. \code{NA} will results for values
below \code{min(x)} if \code{type="left"}, for values
above \code{max(x)} if \code{type="right"} and for values
outside \code{range(x)} if \code{type="mid"}
\item[\code{type}] Character: one of \code{c("left","right","mid")},
indicating whether the left, right or midpoint of the intervals
defined in breaks is returned.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The function uses the base function \code{findInterval}.
\end{Details}
\begin{Value}
A numerical vector of the same length as \code{x}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center, \email{bxc@steno.dk},
\url{http://www.biostat.ku.dk/~bxc/}, with essential input
from Martyn Plummer, IARC.
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{cut}{cut}}, \code{\LinkA{findInterval}{findInterval}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
br <- c(-2,0,1,2.5)
x <- c( rnorm( 10 ), br, -3, 3 )
cbind( x, l=ncut( x, breaks=br, type="l" ),
          m=ncut( x, breaks=br, type="m" ),
          r=ncut( x, breaks=br, type="r" ) )[order(x),]
x <- rnorm( 200 )
plot( x, ncut( x, breaks=br, type="l" ), pch=16, col="blue", ylim=range(x) )
abline( 0, 1 )
abline( v=br )
points( x, ncut( x, breaks=br, type="r" ), pch=16, col="red" )
points( x, ncut( x, breaks=br, type="m" ), pch=16, col="green" )
\end{ExampleCode}
\end{Examples}

\HeaderA{nice}{Nice breakpoints}{nice}
\keyword{manip}{nice}
\begin{Description}\relax
The function calls \code{\LinkA{pretty}{pretty}}
for linear scale. For a log-scale nice are computed using a set of
specified number in a decade.
\end{Description}
\begin{Usage}
\begin{verbatim}
nice(x, log = F, lpos = c(1, 2, 5), ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Numerical vector to
\item[\code{log}] Logical. Is the scale logartimic?
\item[\code{lpos}] Numeric. Numbers between 1 and 10 giving the desired
breakpoints in this interval.
\item[\code{...}] Arguments passed on to \code{pretty} if \code{log}=FALSE
\end{ldescription}
\end{Arguments}
\begin{Value}
A vector of breakpoints.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, \email{bxc@steno.dk}, \url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
pretty
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
nice( exp( rnorm( 100 ) ), log=TRUE )
\end{ExampleCode}
\end{Examples}

\HeaderA{nickel}{A Cohort of Nickel Smelters in South Wales}{nickel}
\keyword{datasets}{nickel}
\begin{Description}\relax
The \code{nickel} data frame has 679 rows and 7 columns.
The data concern a cohort of nickel smelting workers in South Wales and
are taken from Breslow and Day, Volume 2. For comparison purposes,
England and Wales mortality rates (per 1,000,000 per annum)
from lung cancer (ICDs 162 and 163),
nasal cancer (ICD 160), and all causes, by age group and calendar period, are
supplied in the dataset \code{\LinkA{ewrates}{ewrates}}.
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{id}: & Subject identifier (numeric) \\
\code{icd}: & ICD cause of death if dead, 0 otherwise (numeric) \\
\code{exposure}: & Exposure index for workplace (numeric) \\
\code{dob}: & Date of birth (numeric) \\
\code{age1st}: & Age at first exposure (numeric) \\
\code{agein}: & Age at start of follow-up (numeric) \\
\code{ageout}: & Age at end of follow-up (numeric) \\
}
\end{Format}
\begin{Source}\relax
Breslow NE, and Day N, Statistical Methods in Cancer Research. Volume
II: The Design and Analysis of Cohort Studies. IARC Scientific
Publications, IARC:Lyon, 1987.
\end{Source}
\begin{Examples}
\begin{ExampleCode}
data(nickel)
str(nickel)
\end{ExampleCode}
\end{Examples}

\HeaderA{pctab}{Create percentages in a table}{pctab}
\keyword{manip}{pctab}
\keyword{methods}{pctab}
\keyword{array}{pctab}
\begin{Description}\relax
Computes percentages and a margin of totals along a given margin of a table.
\end{Description}
\begin{Usage}
\begin{verbatim}
pctab(TT, margin = length(dim(TT)), dec=1)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{TT}] A table or array object
\item[\code{margin}] Which margin should be the the total?
\item[\code{dec}] How many decimals should be printed?
\end{ldescription}
\end{Arguments}
\begin{Value}
A table, where all dimensions except the one specified \code{margin}
has two extra levels named "All" (where all entries are 100) and "N".
The function prints the table with \code{dec} decimals.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{addmargins}{addmargins}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
Aye <- sample( c("Yes","Si","Oui"), 177, replace=TRUE )
Bee <- sample( c("Hum","Buzz"), 177, replace=TRUE )
Sea <- sample( c("White","Black","Red","Dead"), 177, replace=TRUE )
A <- table( Aye, Bee, Sea )
A
ftable( pctab( A ) )
ftable( pctab( addmargins( A, 1 ), 3 ) )
round( ftable( pctab( addmargins( A, 1 ), 3 ), row.vars=3 ), 1)
\end{ExampleCode}
\end{Examples}

\HeaderA{plot.Lexis}{Lexis diagrams}{plot.Lexis}
\aliasA{lines.Lexis}{plot.Lexis}{lines.Lexis}
\aliasA{points.Lexis}{plot.Lexis}{points.Lexis}
\keyword{hplot}{plot.Lexis}
\keyword{aplot}{plot.Lexis}
\begin{Description}\relax
The follow-up histories represented by a Lexis object can be plotted
using one or two dimensions.  The two dimensional plot is a Lexis
diagram showing follow-up time simultaneously on two time scales.
\end{Description}
\begin{Usage}
\begin{verbatim}
## S3 method for class 'Lexis':
plot(x, time.scale = NULL, breaks="lightgray", ...)
## S3 method for class 'Lexis':
points(x, time.scale = NULL, ...)
## S3 method for class 'Lexis':
lines(x, time.scale = NULL, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class \code{Lexis}
\item[\code{time.scale}] A vector of length 1 or 2 giving the time scales to
be plotted either by name or numerical order
\item[\code{breaks}] a string giving the colour of grid lines to be drawn
when plotting a split Lexis object. Grid lines can be suppressed by
supplying the value \code{NULL} to the \code{breaks} argument
\item[\code{...}] Further graphical parameters to be passed to the plotting
methods. Grids can be drawn using the followin parameters in \code{plot}:
\Itemize{
\item \code{grid} If logical, a background grid is set up
using the axis ticks. If a list, the first component is used as
positions for the vertical lines and the last as positions for the
horizontal. If a nunerical vector, grids on both axes are set up
using the distance between the numbers.
\item \code{col.grid="lightgray"} Color of the background grid.
\item \code{lty.grid=2} Line type for the grid.
\item \code{coh.grid=FALSE} Should a 45 degree grid be plotted?}

\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The plot method for \code{Lexis} objects traces ``life lines'' from
the start to the end of follow-up.  The \code{points} method plots
points at the end of the life lines.

If \code{time.scale} is of length 1, the life lines are drawn
horizontally, with the time scale on the X axis and the id value on the Y
axis. If \code{time.scale} is of length 2, a Lexis diagram is
produced, with diagonal life lines plotted against both time scales
simultaneously.

If \code{lex} has been split along one of the time axes by a call to
\code{splitLexis}, then vertical or horizontal grid lines are plotted
at the break points.
\end{Details}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}, \code{\LinkA{splitLexis}{splitLexis}}
\end{SeeAlso}

\HeaderA{plotEst}{Plot estimates with confidence limits}{plotEst}
\aliasA{linesEst}{plotEst}{linesEst}
\aliasA{pointsEst}{plotEst}{pointsEst}
\keyword{hplot}{plotEst}
\keyword{models}{plotEst}
\begin{Description}\relax
Plots parameter estimates with confidence intervals, annotated with
parameter names. A dot is plotted at the estimate and a horizontal
line extending from the lower to the upper limit is superimposed.
\end{Description}
\begin{Usage}
\begin{verbatim}
plotEst( ests,
            y = dim(ests)[1]:1,
          txt = rownames(ests),
       txtpos = y, 
         ylim = range(y)-c(0.5,0),
         xlab = "",
         xtic = nice(ests[!is.na(ests)], log = xlog),
         xlim = range( xtic ),
         xlog = FALSE,
          pch = 16,
          cex = 1,
          lwd = 2,
          col = "black",
    col.lines = col,
   col.points = col,
         vref = NULL,
         grid = FALSE,
     col.grid = gray(0.9),
  restore.par = TRUE ) 

linesEst( ests, y = dim(ests)[1]:1, pch = 16, cex = 1, lwd = 2,
          col="black", col.lines=col, col.points=col )

pointsEst( ests, y = dim(ests)[1]:1, pch = 16, cex = 1, lwd = 2,
          col="black", col.lines=col, col.points=col )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{ests}] Matrix with three columns: Estimate, lower limit, upper
limit. If a model object is supplied, \code{\LinkA{ci.lin}{ci.lin}} is
invoked for this object first.
\item[\code{y}] Vertical position of the lines.
\item[\code{txt}] Annotation of the estimates.
\item[\code{txtpos}] Vertical position of the text. Defaults to \code{y}.
\item[\code{ylim}] Extent of the vertical axis.
\item[\code{xlab}] Annotation of the horizontal axis.
\item[\code{xtic}] Location of tickmarks on the x-axis.
\item[\code{xlim}] Extent of the x-axis.
\item[\code{xlog}] Should the x-axis be logarithmic?
\item[\code{pch}] What symbol should be used?
\item[\code{cex}] Expansion of the symbol.
\item[\code{col}] Colour of the points and lines.
\item[\code{col.lines}] Colour of the lines.
\item[\code{col.points}] Colour of the symbol.
\item[\code{lwd}] Thickness of the lines.
\item[\code{vref}] Where should vertical reference line(s) be drawn?
\item[\code{grid}] If TRUE, vertical gridlines are drawn at the
tickmarks. If a numerical vector is given vertical lines are drawn
at \code{grid}.
\item[\code{col.grid}] Colour of the vertical gridlines
\item[\code{restore.par}] Should the graphics parameters be restored? If set
to \code{FALSE} the coordinate system will still be available for
additional plotting, and \code{par("mai")} will still have the very
large value set in order to make room for the labelling of the
estimates.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
\code{plotEst} make a news plot, whereas \code{linesEst} and
\code{pointsEst} (identical functions) adds to an existing plot.
\end{Details}
\begin{Value}
NULL
\end{Value}
\begin{Author}\relax
Bendix Carstensen,
\email{bxc@steno.dk},
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
ci.lin
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# Bogus data and a linear model
f <- factor( sample( letters[1:5], 100, replace=TRUE ) )
x <- rnorm( 100 )
y <- 5 + 2 * as.integer( f ) + 0.8 * x + rnorm(100) * 2
m1 <- lm( y ~ f )

# Produce some confidence intervals for contrast to first level
( cf <- summary( m1 )$coef[2:5,1:2] %*% rbind( c(1,1,1), 1.96*(c(0,-1,1) ) ) )

# Plots with increasing amount of bells and whistles
par( mfcol=c(3,2), mar=c(3,3,2,1) )
plotEst( cf )
plotEst( cf, grid=TRUE )
plotEst( cf, grid=TRUE, cex=2, lwd=3 )
plotEst( cf, grid=TRUE, cex=2, col.points="red", col.lines="green" )
plotEst( cf, grid=TRUE, cex=2, col.points="red", col.lines="green",
          xlog=TRUE, xtic=c(1:8), xlim=c(0.8,6) )
rownames( cf )[1] <- "Contrast to fa:\n\n fb"
plotEst( cf, grid=TRUE, cex=2, col.points=rainbow(4), col.lines=rainbow(4), vref=1 )
  \end{ExampleCode}
\end{Examples}

\HeaderA{plotevent}{Plot Equivalence Classes}{plotevent}
\keyword{models}{plotevent}
\keyword{regression}{plotevent}
\keyword{survival}{plotevent}
\begin{Description}\relax
For interval censored data, segments of times between last.well and first.ill are plotted for each conversion in the data. It also plots the equivalence classes.
\end{Description}
\begin{Usage}
\begin{verbatim}
plotevent(last.well, first.ill, data)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{last.well}] Time at which the individuals are
last seen negative for the event 
\item[\code{first.ill}] Time at which the individuals are
first seen positive for the event 
\item[\code{data}] Data with a transversal shape 
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
last.well and first.ill should be written as character in the function.
\end{Details}
\begin{Value}
Graph
\end{Value}
\begin{Author}\relax
Delphine Maucort-Boulch, Bendix Carstensen, Martyn Plummer
\end{Author}
\begin{References}\relax
Carstensen B. Regression models for interval censored survival data:
application to HIV infection in Danish homosexual men.Stat Med. 1996 Oct
30;15(20):2177-89. 

Lindsey JC, Ryan LM. Tutorial in biostatistics methods for
interval-censored data.Stat Med. 1998 Jan 30;17(2):219-38.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Icens}{Icens}}
\end{SeeAlso}

\HeaderA{projection.ip}{Projection of columns of a matrix.}{projection.ip}
\keyword{array}{projection.ip}
\begin{Description}\relax
Projects the columns of the matrix \code{M} on the space spanned by the
columns of the matrix \code{X}, with respect to the inner product
defined by \code{weight}: \code{<x|y>=sum(x*w*y)}.
\end{Description}
\begin{Usage}
\begin{verbatim}
projection.ip(X, M, orth = FALSE, weight = rep(1, nrow(X)))
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{X}] Matrix defining the space to project onto. 
\item[\code{M}] Matrix of columns to be projected. Must have the same number
of rows as \code{X}. 
\item[\code{orth}] Should the projection be on the orthogonal complement to
\code{span(X)}? 
\item[\code{weight}] Weights defining the inner product. Numerical vector of
length \code{nrow(X)}. 
\end{ldescription}
\end{Arguments}
\begin{Value}
A matrix of full rank with columns in \code{span(X)}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc}, with help from Peter Dalgaard.
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{detrend}{detrend}}
\end{SeeAlso}

\HeaderA{rateplot}{Functions to plot rates from a table classified by age and
calendar time (period)}{rateplot}
\aliasA{Aplot}{rateplot}{Aplot}
\aliasA{Cplot}{rateplot}{Cplot}
\aliasA{Pplot}{rateplot}{Pplot}
\keyword{hplot}{rateplot}
\begin{Description}\relax
Produces plots of rates versus age, connected within period or cohort
(\code{Aplot}), rates versus period connected within age-groups
(\code{Pplot}) and rates and rates versus date of birth cohort
(\code{Cplot}). \code{rateplot} is a wrapper for these, allowing
to produce the four classical displays with a single call.
\end{Description}
\begin{Usage}
\begin{verbatim}
rateplot( rates,
          which = c("ap","ac","pa","ca"),
            age = as.numeric( dimnames( rates )[[1]] ),
            per = as.numeric( dimnames( rates )[[2]] ),
           grid = FALSE,
         a.grid = grid,
         p.grid = grid,
         c.grid = grid,
          ygrid = grid,
       col.grid = gray( 0.9 ),
          a.lim = range( age, na.rm=TRUE ) + c(0,diff( range( age ) )/30),
          p.lim = range( per, na.rm=TRUE ) + c(0,diff( range( age ) )/30),
          c.lim = NULL, 
           ylim = range( rates[rates>0], na.rm=TRUE ),
             at = NULL,
         labels = paste( at ),
          a.lab = "Age at diagnosis",
          p.lab = "Date of diagnosis",
          c.lab = "Date of birth",
           ylab = "Rates",
           type = "l",
            lwd = 2,
            lty = 1,
         log.ax = "y",
            las = 1,
            ann = FALSE,
          a.ann = ann,
          p.ann = ann,
          c.ann = ann,
          xannx = 1/20,
        cex.ann = 0.8,
         a.thin = seq( 1, length( age ), 2 ),
         p.thin = seq( 1, length( per ), 2 ),
         c.thin = seq( 2, length( age ) + length( per ) - 1, 2 ),
            col = par( "fg" ),
          a.col = col,
          p.col = col,
          c.col = col,
            ... )

Aplot( rates, age = as.numeric( dimnames( rates )[[1]] ),
       per = as.numeric( dimnames( rates )[[2]] ), grid = FALSE,
       a.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       a.lim = range( age, na.rm=TRUE ), ylim = range( rates[rates>0], na.rm=TRUE ),
       at = NULL, labels = paste( at ), a.lab = names( dimnames( rates ) )[1],
       ylab = deparse( substitute( rates ) ), type = "l", lwd = 2, lty = 1,
       col = par( "fg" ), log.ax = "y", las = 1, c.col = col, p.col = col,
       c.ann = FALSE, p.ann = FALSE, xannx = 1/20, cex.ann = 0.8,
       c.thin = seq( 2, length( age ) + length( per ) - 1, 2 ),
       p.thin = seq( 1, length( per ), 2 ), p.lines = TRUE,
       c.lines = !p.lines, ... )

Pplot( rates, age = as.numeric( dimnames( rates )[[1]] ),
       per = as.numeric( dimnames( rates )[[2]] ), grid = FALSE,
       p.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       p.lim = range( per, na.rm=TRUE ) + c(0,diff(range(per))/30),
       ylim = range( rates[rates>0], na.rm=TRUE ), p.lab = names( dimnames( rates ) )[2],
       ylab = deparse( substitute( rates ) ), at = NULL, labels = paste( at ),
       type = "l", lwd = 2, lty = 1, col = par( "fg" ), log.ax = "y",
       las = 1, ann = FALSE, cex.ann = 0.8, xannx = 1/20,
       a.thin = seq( 1, length( age ), 2 ), ... )

Cplot( rates, age = as.numeric( rownames( rates ) ),
       per = as.numeric( colnames( rates ) ), grid = FALSE,
       c.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       c.lim = NULL, ylim = range( rates[rates>0], na.rm=TRUE ),
       at = NULL, labels = paste( at ), c.lab = names( dimnames( rates ) )[2],
       ylab = deparse( substitute( rates ) ), type = "l", lwd = 2, lty = 1,
       col = par( "fg" ), log.ax = "y", las = 1, xannx = 1/20, ann = FALSE,
       cex.ann = 0.8, a.thin = seq( 1, length( age ), 2 ), ...  )

\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{rates}] A two-dimensional table (or array) with rates to be plotted. It is
assumed that the first dimension is age and the second is period.
\item[\code{which}] A character vector with elements from
\code{c("ap","ac","apc","pa","ca")}, indication which plots should
be produced. One plot per element is produced. The first letter
indicates the x-axis of the plot, the remaining which groups
should be connected, i.e. \code{"pa"} will plot rates versus
period and connect age-classes, and \code{"apc"} will plot rates
versus age, and connect both periods and cohorts.
\item[\code{age}] Numerical vector giving the means of the
age-classes. Defaults to the rownames of \code{rates} as numeric.
\item[\code{per}] Numerical vector giving the means of the periods. Defaults
to the columnnames of \code{rates} as numeric.
\item[\code{grid}] Logical indicating whether a background grid should be drawn.
\item[\code{a.grid}] Logical indicating whether a background grid on the
age-axis should be drawn. If numerical it indicates the
age-coordinates of the grid.
\item[\code{p.grid}] do. for the period.
\item[\code{c.grid}] do. for the cohort.
\item[\code{ygrid}] do. for the rate-dimension.
\item[\code{col.grid}] The colour of the grid.
\item[\code{a.lim}] Range for the age-axis.
\item[\code{p.lim}] Range for the period-axis.
\item[\code{c.lim}] Range for the cohort-axis.
\item[\code{ylim}] Range for the y-axis (rates).
\item[\code{at}] Position of labels on the y-axis (rates).
\item[\code{labels}] Labels to put on the y-axis (rates).
\item[\code{a.lab}] Text on the age-axis. Defaults to "Age".
\item[\code{p.lab}] Text on the period-axis. Defaults to "Date of diagnosis".
\item[\code{c.lab}] Text on the cohort-axis. Defaults to "Date of birth".
\item[\code{ylab}] Text on the rate-axis. Defaults to the name of the rate-table.
\item[\code{type}] How should the curves be plotted. Defaults to \code{"l"}.
\item[\code{lwd}] Width of the lines. Defaults to 2.
\item[\code{lty}] Which type of lines should be used. Defaults to 1, a solid line.
\item[\code{log.ax}] Character with letters from \code{"apcyr"}, indicating
which axes should be logarithmic. \code{"y"} and \code{"r"} both
refer to the rate scale. Defaults to \code{"y"}.
\item[\code{las}] see \code{par}.
\item[\code{ann}] Should the curves be annotated?
\item[\code{a.ann}] Logical indicating whether age-curves should be annotated.
\item[\code{p.ann}] do. for period-curves.
\item[\code{c.ann}] do. for cohort-curves.
\item[\code{xannx}] The fraction that the x-axis is expanded when curves are annotated.
\item[\code{cex.ann}] Expansion factor for characters annotating curves.
\item[\code{a.thin}] Vector of integers indicating which of the age-classes
should be labelled.
\item[\code{p.thin}] do. for the periods.
\item[\code{c.thin}] do. for the cohorts.
\item[\code{col}] Colours for the curves.
\item[\code{a.col}] Colours for the age-curves.
\item[\code{p.col}] do. for the period-curves.
\item[\code{c.col}] do. for the cohort-curves.
\item[\code{p.lines}] Should rates from the same period be connected?
\item[\code{c.lines}] Should rates from the same cohort be connected?
\item[\code{...}] Additional arguments pssed on to \code{matlines} when
plotting the curves.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Zero values of the rates are ignored. They are neiter in the plot nor in
the calculation of the axis ranges.
\end{Details}
\begin{Value}
\code{NULL}. The function is used for its side-effect, the plot.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center,
\url{http://www.pubhealth.ku.dk/~bxc/}
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{apc.frame}{apc.frame}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data( blcaIT )
attach(blcaIT)

# Table of rates:
bl.rate <- tapply( D, list(age,period), sum ) /
           tapply( Y, list(age,period), sum )
bl.rate

# The four classical plots:
par( mfrow=c(2,2) )
rateplot( bl.rate*10^6 )

# The labels on the vertical axis could be nicer:
rateplot( bl.rate*10^6, at=10^(-1:3), labels=c(0.1,1,10,100,1000) ) 

# More bells an whistles
par( mfrow=c(1,3), mar=c(3,3,1,1), oma=c(0,3,0,0), mgp=c(3,1,0)/1.6 )
rateplot( bl.rate*10^6, ylab="", ann=TRUE, which=c("AC","PA","CA"),
                      at=10^(-1:3), labels=c(0.1,1,10,100,1000),
                      col=topo.colors(11), cex.ann=1.2 ) 
\end{ExampleCode}
\end{Examples}

\HeaderA{Relevel}{Reorder and combine levels of a factor}{Relevel}
\keyword{manip}{Relevel}
\begin{Description}\relax
The levels of a factor are re-ordered so that the levels specified by
\code{ref} is first and the others are moved down. This is useful for
\code{contr.treatment} contrasts which take the first level as the
reference. Levels may also be combined.
\end{Description}
\begin{Usage}
\begin{verbatim}
Relevel(f, ref, first = TRUE, collapse="+" )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] An unordered factor
\item[\code{ref}] The names or numbers of levels to be the first. If \code{ref}
is a list, factor levels mentioned in each list element are
combined. If the list is named the names are used as new factor levels.
\item[\code{first}] Should the levels mentioned in ref come before those not?
\item[\code{collapse}] String used when collapsing factor levels.
\end{ldescription}
\end{Arguments}
\begin{Value}
An unordered factor.
\end{Value}
\begin{Examples}
\begin{ExampleCode}
ff <- factor( sample( letters[1:5], 100, replace=TRUE ) )
table( ff, Relevel( ff, list( AB=1:2, "Dee"=4, c(3,5) ) ) )
table( ff, rr=Relevel( ff, list( 5:4, Z=c("c","a") ), coll="-und-", first=FALSE ) )
\end{ExampleCode}
\end{Examples}

\HeaderA{ROC}{Function to compute and draw ROC-curves.}{ROC}
\keyword{manip}{ROC}
\keyword{htest}{ROC}
\begin{Description}\relax
Computes sensitivity, specificity and positive and negative predictive
values for a test based on dichotomizing along the variable
\code{test}, for prediction of \code{stat}. Alternatively a
model formula may given, in which case the the linear predictor is the
test variable and the response is taken as the true status variable.
Plots curves of these and a ROC-curve.
\end{Description}
\begin{Usage}
\begin{verbatim}
ROC( test = NULL,
     stat = NULL,
     form = NULL,
     plot = c("sp", "ROC"),
       PS = is.null(test),    
       PV = TRUE,             
       MX = TRUE,             
       MI = TRUE,             
      AUC = TRUE,             
     grid = seq(0,100,10),
 col.grid = gray( 0.9 ),
     cuts = NULL,
      lwd = 2,
     data = parent.frame(), 
      ... )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{test}] Numerical variable used for prediction. 
\item[\code{stat}] Logical variable of true status. 
\item[\code{form}] Formula used in a logistic regression. If this is given,
\code{test} and \code{stat} are ignored. If not given then
both \code{test} and \code{stat} must be supplied. 
\item[\code{plot}] Character variable. If "sp", the a plot of sensitivity,
specificity and predictive values against test is produced, if "ROC" a
ROC-curve is plotted. Both may be given.
\item[\code{PS}] logical, if TRUE the x-axis in the
plot "ps"-plot is the the predicted probability for
\code{stat}==TRUE, otherwise it is the scale of \code{test} if this
is given otherwise the scale of the linear predictor from the
logistic regression.
\item[\code{PV}] Should sensitivity, specificity and
predictive values at the optimal cutpoint be given on the ROC plot? 
\item[\code{MX}] Should the ``optimal cutpoint'' (i.e. where sens+spec is
maximal) be indicated on the ROC curve?
\item[\code{MI}] Should model summary from the logistic
regression model be printed in the plot?
\item[\code{AUC}] Should the area under the curve (AUC) be printed in the ROC
plot?
\item[\code{grid}] Numeric or logical. If FALSE no background grid is
drawn. Otherwise a grid is drawn on both axes at \code{grid} percent.
\item[\code{col.grid}] Colour of the grid lines drawn.
\item[\code{cuts}] Points on the test-scale to be annotated on the
ROC-curve. 
\item[\code{lwd}] Thickness of the curves
\item[\code{data}] Data frame in which to interpret the variables.
\item[\code{...}] Additional arguments for the plotting of the
ROC-curve. Passed on to \code{plot}
\end{ldescription}
\end{Arguments}
\begin{Value}
A list with two components:
\begin{ldescription}
\item[\code{res}] dataframe with variables sn, sp, pvp, pvn and fv. The
latter is the unique values of test (for PS==FALSE ) or linear predictor from the
logistic regression
\item[\code{lr}] glm object with the logistic regression result used for
construction of the ROC curve
\end{ldescription}

0, 1 or 2 plots are produced according to the setting of \code{plot}.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center \& University of
Copenhagen,
\url{http://www.biostat.ku.dk/~bxc}
\end{Author}
\begin{References}\relax
\end{References}
\begin{Examples}
\begin{ExampleCode}
x <- rnorm( 100 )
z <- rnorm( 100 )
w <- rnorm( 100 )
tigol <- function( x ) 1 - ( 1 + exp( x ) )^(-1)
y <- rbinom( 100, 1, tigol( 0.3 + 3*x + 5*z + 7*w ) )
ROC( form = y ~ x + z, plot="ROC" )
\end{ExampleCode}
\end{Examples}

\HeaderA{S.typh}{Salmonella Typhimurium outbreak 1996 in Denmark.}{S.typh}
\keyword{datasets}{S.typh}
\begin{Description}\relax
Matched case-control study of food poisoning.
\end{Description}
\begin{Format}\relax
A data frame with 136 observations on the following 15 variables:
\Tabular{rl}{
\code{id}: & Person identification \\
\code{set}: & Matched set indicator \\
\code{case}: & Case-control status (1:case, 0:control \\
\code{age}: & Age of individual \\
\code{sex}: & Sex of individual (1:male, 2:female) \\ 
\code{abroad}: & Within the last two weeks visited abroad (1:yes, 0:no) \\
\code{beef}: & Within the last two weeks eaten beef \\
\code{pork}: & Within the last two weeks eaten pork \\
\code{veal}: & Within the last two weeks eaten veal \\
\code{poultry}: & Within the last two weeks eaten poultry \\
\code{liverp}: & Within the last two weeks eaten liverpaste \\
\code{veg}: & Within the last two weeks eaten vegetables \\
\code{fruit}: & Within the last two weeks eaten fruit \\
\code{egg}: & Within the last two weeks eaten eggs \\
\code{plant7}: & Within the last two weeks eaten meat from plant no. 7 \\
}
\end{Format}
\begin{Details}\relax
In the fall of 1996 an unusually large number of Salmonella
Typhimurium cases were recorded in Fyn county in Denmark. The Danish
Zoonosis Centre set up a matched case-control study to find the
sources. Cases and two age-, sex- and residency-matched controls were
telephone interviewed about their food intake during the last two
weeks.

The participants were asked at which retailer(s) they had purchased
meat. Retailers were independently of this linked to meat processing
plants, and thus participants were linked to meat processing
plants. This way persons could be linked to (amongst other) plant no 7.
\end{Details}
\begin{Source}\relax
Tine Hald.
\end{Source}
\begin{References}\relax
Mølbak K and Hald T: Salmonella Typhimurium outbreak in late summer
1996. A Case-control study. (In Danish:
Salmonella typhimurium udbrud på Fyn sensommeren
1996. En case-kontrol undersøgelse.) Ugeskrift for Læger.,
159(36):5372-7, 1997.
\end{References}
\begin{Examples}
\begin{ExampleCode}
data(S.typh)
\end{ExampleCode}
\end{Examples}

\HeaderA{split.Lexis}{Split follow-up time in a Lexis object}{split.Lexis}
\aliasA{splitLexis}{split.Lexis}{splitLexis}
\keyword{manip}{split.Lexis}
\begin{Description}\relax
The \code{splitLexis} function divides each row of a \code{Lexis}
object into disjoint follow-up intervals according to the supplied
break points.
\end{Description}
\begin{Usage}
\begin{verbatim}
splitLexis(lex, breaks)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{lex}] an object of class \code{Lexis}
\item[\code{breaks}] a named list of numeric vectors giving the break points
on one or more time scales. Optionally, a single vector of
break points may be given, in which case the first time scale is assumed.

\end{ldescription}
\end{Arguments}
\begin{Value}
An object of class \code{Lexis} with multiple rows for each row of
the argument \code{lex}. Each row of the new \code{Lexis} object
contains the part of the follow-up interval that falls inside one of
the time bands defined by the break points.

The variables representing the various time scales, are appropriately
updated in the new \code{Lexis} object. The entry and exit status
variables are also updated according to the rule that the entry status
is retained until the end of follow-up. All other variables are
considered to represent variables that are constant in time, and so
are replicated across all rows having the same id value.
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{timeBand}{timeBand}}
\end{SeeAlso}

\HeaderA{start.Lexis}{Time series methods for Lexis objects}{start.Lexis}
\aliasA{deltat.Lexis}{start.Lexis}{deltat.Lexis}
\aliasA{entry}{start.Lexis}{entry}
\aliasA{exit}{start.Lexis}{exit}
\aliasA{status}{start.Lexis}{status}
\keyword{ts}{start.Lexis}
\begin{Description}\relax
Extract the entry time, exit time, status, or duration of follow-up from a
\code{Lexis} object.
\end{Description}
\begin{Usage}
\begin{verbatim}
entry(x, time.scale = NULL)
exit(x, time.scale = NULL)
status(x, at=c("exit","entry"))
## S3 method for class 'Lexis':
deltat(x, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an object of class \code{Lexis}
\item[\code{time.scale}] a string or integer indicating the time scale. If
omitted, the first time scale is used as a default
\item[\code{at}] string indicating the time point at which status is to be measured
\item[\code{...}] optional arguments to the \code{deltat} method
\end{ldescription}
\end{Arguments}
\begin{Value}
The \code{entry} and \code{exit} functions return a vector containing
the entry times and exit times, respectively, on the requested time
scale. The \code{status} function returns the status either at entry
or (by default) at exit, and the \code{deltat} method returns the length
of the follow-up interval.
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}
\end{SeeAlso}

\HeaderA{stattable.funs}{Special functions for use in stat.table}{stattable.funs}
\aliasA{count}{stattable.funs}{count}
\aliasA{percent}{stattable.funs}{percent}
\aliasA{ratio}{stattable.funs}{ratio}
\keyword{iteration}{stattable.funs}
\keyword{category}{stattable.funs}
\begin{Description}\relax
These functions may be used as \code{contents} arguments to the
function \code{stat.table}. They are defined internally in
\code{stat.table} and have no independent existence.
\end{Description}
\begin{Usage}
\begin{verbatim}
count(id)
ratio(d,y,scale=1, na.rm=TRUE)
percent(...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{id}] numeric vector in which identical values identify the
same individual.
\item[\code{d, y}] numeric vectors of equal length (\code{d} for Deaths,
\code{y} for person-Years)
\item[\code{scale}] a scalar giving a value by which the ratio should be
multiplied
\item[\code{na.rm}] a logical value indicating whether \code{NA} values should
be stripped before computation proceeds.
\item[\code{...}] a list of variables taken from the \code{index} argument
to \code{\LinkA{stat.table}{stat.table}}
\end{ldescription}
\end{Arguments}
\begin{Value}
When used as a \code{contents} argument to \code{stat.table}, these
functions create the following tables:
\begin{ldescription}
\item[\code{this-is-escaped-codenormal-bracket30bracket-normal}] If given without argument (\code{count()}) it
returns a contingency table of counts. If given an \code{id}
argument it returns a table of the number of different values of
\code{id} in each cell, i.e. how many persons contribute in each
cell.
\item[\code{this-is-escaped-codenormal-bracket36bracket-normal}] returns a table of values
\code{scale * sum(d)/sum(y)}
\item[\code{this-is-escaped-codenormal-bracket40bracket-normal}] returns a table of percentages of the
classifying variables. Variables that are in the \code{index}
argument to \code{stat.table} but not in the call to
\code{percent} are used to define strata, within which the
percentages add up to 100.
\end{ldescription}

normal-bracket46bracket-normal
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{stat.table}{stat.table}}
\end{SeeAlso}

\HeaderA{stat.table}{Tables of summary statistics}{stat.table}
\aliasA{print.stat.table}{stat.table}{print.stat.table}
\keyword{iteration}{stat.table}
\keyword{category}{stat.table}
\begin{Description}\relax
\code{stat.table} creates tabular summaries of the data, using a
limited set of functions. A list of index variables is used
to cross-classify summary statistics.
\end{Description}
\begin{Usage}
\begin{verbatim}
stat.table(index, contents = count(), data, margins = FALSE)
print.stat.table(x, width=7, digits,...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{index}] A factor, or list of factors, used for cross-classification.
If the list is named, then the names will be used when printing the
table. This feature can be used to give informative labels to the
variables.
\item[\code{contents}] A function call, or list of function calls. Only a
limited set of functions may be called (See Details below).  If the
list is named, then the names will be used when printing the table.
\item[\code{data}] an optional data frame containing the variables to be
tabulated. If this is omitted, the variables will be searched for in the
calling environment.
\item[\code{margins}] a logical scalar or vector indicating which  marginal
tables are to be calculated.  If a vector, it should be the same
length as the \code{index} argument: values corresponding to
\code{TRUE} will be retained in marginal tables.
\item[\code{x}] an object of class \code{stat.table}.
\item[\code{width}] a scalar giving the minimum column width when printing.
\item[\code{digits}] a scalar, or named vector, giving the number
of digits to print after the decimal point. If a named vector is used,
the names should correspond to one of the permitted functions (See
Details below) and all results obtained with that function will be
printed with the same precision.
\item[\code{...}] further arguments passed to other print methods.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
This function is similar to \code{tapply}, with some enhancements:
multiple summaries of multiple variables may be mixed in the
same table; marginal tables may be calculated; columns and rows may
be given informative labels; pretty printing may be controlled by the
associated print method.

This function is not a replacement for \code{tapply} as it also has
some limitations.  The only functions that may be used in the
\code{contents} argument  are: \code{\LinkA{count}{count}},
\code{\LinkA{mean}{mean}}, \code{\LinkA{weighted.mean}{weighted.mean}}, \code{\LinkA{sum}{sum}},
\code{\LinkA{quantile}{quantile}}, \code{\LinkA{median}{median}}, \code{\LinkA{IQR}{IQR}},
\code{\LinkA{max}{max}}, \code{\LinkA{min}{min}}, \code{\LinkA{ratio}{ratio}}, and
\code{\LinkA{percent}{percent}}.

The \code{count()} function, which is the default, simply creates a
contingency table of counts.  The other functions are applied to
each cell created by combinations of the \code{index} variables.
\end{Details}
\begin{Value}
An object of class \code{stat.table}, which is a multi-dimensional
array. A print method is available to create formatted one-way and
two-way tables.
\end{Value}
\begin{Note}\relax
The permitted functions in the contents list 
are defined inside \code{stat.table}.  They have the same interface as
the functions callable from the command line, except for two
differences. If there is an argument \code{na.rm} then its default
value is always \code{TRUE}. A second difference is that the
\code{quantile} function can only produce a single quantile in each call.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{table}{table}}, \code{\LinkA{tapply}{tapply}},
\code{\LinkA{mean}{mean}}, \code{\LinkA{weighted.mean}{weighted.mean}},
\code{\LinkA{sum}{sum}}, \code{\LinkA{quantile}{quantile}},
\code{\LinkA{median}{median}}, \code{\LinkA{IQR}{IQR}},
\code{\LinkA{max}{max}}, \code{\LinkA{min}{min}}, \code{\LinkA{ratio}{ratio}},
\code{\LinkA{percent}{percent}}, \code{\LinkA{count}{count}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data(warpbreaks)
# A one-way table
stat.table(tension,list(count(),mean(breaks)),data=warpbreaks)
# The same table with informative labels
stat.table(index=list("Tension level"=tension),list(N=count(),
           "mean number of breaks"=mean(breaks)),data=warpbreaks)

# A two-way table
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks)  
# The same table with margins over tension, but not wool
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks,
           margins=c(TRUE, FALSE))

# A table of column percentages
stat.table(list(tension,wool), percent(tension), data=warpbreaks)
# Cell percentages, with margins
stat.table(list(tension,wool),percent(tension,wool), margin=TRUE,
           data=warpbreaks)

# A table with multiple statistics
# Note how each statistic has its own default precision
a <- stat.table(index=list(wool,tension),
                contents=list(count(),mean(breaks),percent (wool)),
                data=warpbreaks)
print(a)
# Print the percentages rounded to the nearest integer
print(a, digits=c(percent=0))

# An Epidemiological example with follow-up time
data(nickel)
str(nickel)

# Make a grouped version of the exposure variable
nickel$egr <- cut( nickel$exposure, breaks=c(0, 0.5, 5, 10, 100), right=FALSE )
stat.table( egr, list( count(), percent(egr), mean( age1st ) ), data=nickel )

# Split the follow-up time by current age
nickel.ex <-
W.Lexis( entry=agein, exit=ageout, fail=icd %in% c(162,163),
         origin=0, breaks=seq(0,100,20),
         include=list( id, exposure, egr, age1st, icd ), data=nickel )
str( nickel.ex )

# Table of rates
stat.table( Time, list( n=count(), N=count(id), D=sum(Fail),
                        "Rate/1000"=ratio(Fail,Exit-Entry,1000) ),
            margin=1, data=nickel.ex )
# Two-way table of rates and no. persons contributing
stat.table( list(age=Time, Exposure=egr),
            list( N=count(id), D=sum(Fail), Y=sum((Exit-Entry)/1000),
                  Rate=ratio(Fail,Exit-Entry,1000) ),
            margin=TRUE, data=nickel.ex )
\end{ExampleCode}
\end{Examples}

\HeaderA{subset.Lexis}{Subsetting Lexis objects}{subset.Lexis}
\keyword{manip}{subset.Lexis}
\begin{Description}\relax
Return subsets of Lexis objects which meet conditions
\end{Description}
\begin{Usage}
\begin{verbatim}
## S3 method for class 'Lexis':
subset(x, ...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an object of class \code{Lexis}
\item[\code{...}] additional arguments to be passed to \code{subset.data.frame}
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The subset method for \code{Lexis} objects works exactly as the
method for data frames.
\end{Details}
\begin{Value}
A \code{Lexis} object with selected rows and columns.
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}, \code{\LinkA{merge.Lexis}{merge.Lexis}}
\end{SeeAlso}

\HeaderA{tabplot}{Graphical display of a 2-way contingency table}{tabplot}
\keyword{hplot}{tabplot}
\begin{Description}\relax
Entries in a table are plotted as rectangles proportional to the entry
in the table. Width of rectangles are proportional to column totals,
height proportional to entries within each column, hence areas are
proportional to entries in the table.
\end{Description}
\begin{Usage}
\begin{verbatim}
  tabplot( M,
         col,
      border = "black",
         lwd = 2,
     collabs = TRUE,
     rowlabs = NULL,
       equal = FALSE,
         las = 1,
        main = NULL,
    cex.main = 1.0,
       vaxis = FALSE )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{M}] Two-way table
\item[\code{col}] colors to use for coloring within each column. Defaults to
a grayscale. May also be a function that takes an integer argument,
as e.g. \code{rainbow()}.
\item[\code{border}] color of borders around rectangles.
\item[\code{lwd}] width of the lines around rectangles.
\item[\code{collabs}] should colums be labelled.
\item[\code{rowlabs}] character "r" or "l": rows labelled on left or right side
\item[\code{equal}] should colums be plotted of equal width? If yes a plot
similar to that obtainable from barplot is the result.
\item[\code{las}] how should labelling be rotated.
\item[\code{main}] heading for the plot
\item[\code{cex.main}] character expansion for the heading.
\item[\code{vaxis}] should a vertical axis be drawn. If character it gives
the side where it is drawn.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The function offers a few more facilities for two-way tables than
\code{\LinkA{mosaicplot}{mosaicplot}}, but is restricted to two-way tables as
input.
\end{Details}
\begin{Value}
NULL. The function is used for its sideeffects.
\end{Value}
\begin{Author}\relax
Bendix Carstensen, Steno Diabetes Center \& Dept. of Biostatistics,
University of Copenhagen
\email{bxc@steno.dk},
\url{http://www.pubhealth.ku.dk/~bxc}
\end{Author}
\begin{SeeAlso}\relax
See Also \code{\LinkA{barplot}{barplot}}, \code{\LinkA{plot.table}{plot.table}},
\code{\LinkA{mosaicplot}{mosaicplot}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
b <- sample( letters[1:4], 300, replace=TRUE, prob=c(3,1,2,4)/10 )
a <- rnorm( 300 ) - as.integer( factor( b ) ) / 8
tb <- table( cut( a, -3:2 ), b )
tabplot( tb )
tabplot( tb, rowlabs="right", col=heat.colors )

# Very similar plots
ptb <- sweep( tb, 2, apply( tb, 2, sum ), "/" )
par( mfrow=c(2,2) )
barplot( ptb, space=0 )
tabplot( tb, equal=TRUE, lwd=1 )
tabplot( tb, equal=TRUE, lwd=1, rowlabs="l" )
tabplot( tb, equal=FALSE, lwd=1, rowlabs="l" )
\end{ExampleCode}
\end{Examples}

\HeaderA{thoro}{Thorotrast Study}{thoro}
\keyword{datasets}{thoro}
\begin{Description}\relax
The \code{thoro} data frame has 2470 rows and 14 columns.
Each row represents one patient that have had cerebral angiography (X-ray of
the brain) with an injected contrast medium, either Thorotrast or
another one (the controls).
\end{Description}
\begin{Format}\relax
This data frame contains the following columns:
\Tabular{rl}{
\code{id}:       & Identification of person. \\
\code{sex}:      & Sex, 1: male / 2: female. \\
\code{birthdat}: & Date of birth, \code{Date} variable. \\
\code{contrast}: & Group, 1: Thorotrast / 2: Control. \\
\code{injecdat}: & Date of contrast injection, \code{Date} variable. \\
\code{volume}:   & Injected volume of Thorotrast in ml. Control
patients have a 0 in this variable. \\
\code{exitdat}:  & Date of exit from the study, \code{Date} variable. \\
\code{exitstat}: & Status at exit, 1: dead / 2: alive,
censored at closing of study, 20 February 1992 / 3:
censored alive at some earlier date. \\
\code{cause}:    & Cause of death. See causes in the helpfile for
\code{\LinkA{gmortDK}{gmortDK}} \\
\code{liverdat}: & Date of liver cancer diagnosis, \code{Date} variable. \\
\code{liver}:    & Indicator of liver cancer diagnosis. Not all livercancers
are histologically verified, hence
\code{liver >= hepcc + chola + hmang} \\
\code{hepcc}:    & Hepatocellular carcinoma at \code{liverdat}. \\
\code{chola}:    & Cholangiocellular carcinoma at \code{liverdat}. \\
\code{hmang}:    & Haemangisarcoma carcinoma at \code{liverdat}. \\
}
\end{Format}
\begin{Source}\relax
M Andersson, M Vyberg, J Visfeldt, B Carstensen \& HH Storm:
Primary liver tumours among Danish patients exposed to Thorotrast.
Radiation Research, 137, pp. 262--273, 1994.

M Andersson, B Carstensen HH Storm: Mortality and cancer
incidence after cerebral angiography. Radiation Research, 142,
pp. 305--320, 1995.
\end{Source}
\begin{SeeAlso}\relax
\code{\LinkA{mortDK}{mortDK}}, \code{\LinkA{gmortDK}{gmortDK}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data(thoro)
str(thoro)
\end{ExampleCode}
\end{Examples}

\HeaderA{time.band}{Extract time band data from a split Lexis object}{time.band}
\aliasA{breaks}{time.band}{breaks}
\aliasA{timeBand}{time.band}{timeBand}
\keyword{attribute}{time.band}
\begin{Description}\relax
The break points of a \code{Lexis} object (created by a call to
\code{splitLexis}) divide the follow-up intervals into time bands
along a given time scale. The \code{breaks} function returns
the break points, for a given time scale, and the \code{timeBand}
classifies each row into one of the time bands.
\end{Description}
\begin{Usage}
\begin{verbatim}
timeBand(lex, time.scale, type)
breaks(lex, time.scale)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{lex}] an object of class \code{Lexis}
\item[\code{time.scale}] a character or integer vector of length 1
identifying the time scale of interest
\item[\code{type}] a string that determines how the time bands are labelled.
See Details below
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
Time bands may be labelled in various ways according to the
\code{type} argument. The permitted values of the \code{type}
argument, and the corresponding return values are:
\item["factor"] a factor (unordered) with labels "(left,right]"
\item["integer"] a numeric vector with integer codes starting from 0
\item["left"] the left-hand limit of the time band
\item["middle"] the middle of the time band
\item["right"] the right-hand limit of the time band
\end{Details}
\begin{Value}
The \code{breaks} function returns a vector of break points
for the \code{Lexis} object, or NULL if no break points have been
defined by a call to \code{splitLexis}.  The \code{timeBand}
function returns a numeric vector or factor, depending on the value
of the \code{type} argument.
\end{Value}
\begin{Note}\relax
A newly created \code{Lexis} object has no break points defined.
In this case, \code{breaks} will return NULL, and
\code{timeBand} will return a degenerate factor with one level
labelled "(-Inf,Inf]".
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}
\end{SeeAlso}

\HeaderA{time.scales}{The time scales of a Lexis object}{time.scales}
\aliasA{timeScales}{time.scales}{timeScales}
\keyword{attribute}{time.scales}
\begin{Description}\relax
Function to get the names of the time scales of a \code{Lexis} object.
\end{Description}
\begin{Usage}
\begin{verbatim}
timeScales(x)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an object of class \code{Lexis}
\end{ldescription}
\end{Arguments}
\begin{Value}
A character vector containing the names of the variables in \code{x}
that represent the time scales
\end{Value}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}}, \code{\LinkA{splitLexis}{splitLexis}}
\end{SeeAlso}

\HeaderA{twoby2}{Analysis of a two by two table}{twoby2}
\keyword{univar}{twoby2}
\keyword{htest}{twoby2}
\begin{Description}\relax
Computes the usual measures of association in a 2 by 2 table with
confidence intervals. Also produces asymtotic and exact tests. Assumes
that comparison of probability of the first column level between
levels of the row variable is of interest. Output requires that the
input matrix has meaningful row and column labels.
\end{Description}
\begin{Usage}
\begin{verbatim}
twoby2(exposure, outcome,
       alpha = 0.05, print = TRUE, dec = 4,
       conf.level = 1-alpha, F.lim = 10000)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{exposure}] If a table the analysis is based on the first two rows
and first two columns of this. If a variable, this variable is
tabulated against
\item[\code{outcome}] as the second variable
\item[\code{alpha}] Significance level
\item[\code{print}] Should the results be printed?
\item[\code{dec}] Number of decimals in the printout.
\item[\code{conf.level}] 1-\code{alpha}
\item[\code{F.lim}] If the table total exceeds \code{F.lim}, Fisher's exact
test is not computed
\end{ldescription}
\end{Arguments}
\begin{Value}
A list with elements:
\begin{ldescription}
\item[\code{table}] The analysed 2 x 2 table augmented with probabilities and
confidence intervals. The confidence intervals for the probabilities
are computed using the normal approximation to the
log-odds. Confidence intervals for the difference of proportions are
computed using method 10 from Newcombe, Stat.Med. 1998, 17, pp.873
ff.
\item[\code{measures}] A table of Odds-ratios and relative risk with
confidence intervals.
\item[\code{p.value}] Exact p-value for the null hypothesis of OR=1
\end{ldescription}
\end{Value}
\begin{Author}\relax
Mark Myatt. Modified by Bendix Carstensen.
\end{Author}
\begin{Examples}
\begin{ExampleCode}
Treat <- sample(c("A","B"), 50, rep=TRUE )
Resp <- c("Yes","No")[1+rbinom(50,1,0.3+0.2*(Treat=="A"))]
twoby2( Treat, Resp )                 
twoby2( table( Treat, Resp )[,2:1] ) # Comparison the other way round
\end{ExampleCode}
\end{Examples}

\HeaderA{W.Lexis}{Split follow-up time in cohort studies.}{W.Lexis}
\keyword{manip}{W.Lexis}
\begin{Description}\relax
This is an old version of time-splitting. Consult the new version,
\code{\LinkA{Lexis}{Lexis}}.

For cohort input data the follow-up time is chopped in pieces along
several time scales, and a dataframe of follow-up intervals is
returned. Entry and exit times are assumed to be in the same timescale
(the input time scale).
\end{Description}
\begin{Usage}
\begin{verbatim}
W.Lexis( entry = 0,
          exit,
          fail,
        origin = 0,
         scale = 1,
        breaks,
       include = NULL,
          data = NULL )
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{entry}] Date of entry on the input timescale. Numerical variable.
\item[\code{exit}] Date of exit on the input timescale. Numerical variable.
\item[\code{fail}] Failure indicator.
\item[\code{origin}] Origin of the output timescale(s) on the input
timescale. If for example the input timescale is calendar time and
the output timescale is (current) age, the the origin is date of
birth. If more than one timescale is used for splitting time
this is a list. Elements of the list must be named and must have the
same names as those in \code{scale} and \code{breaks}.
\item[\code{scale}] Scale of the output timescale(s) relative to the input
timescale. Elements of the list must be named and have the same
names as those in \code{origin} and \code{breaks}.
\item[\code{breaks}] Points on the output scale where the follow-up is
cut. If more than one timescale is used for splitting time this is a
list. Elements of the list must be named and must have the same
names as those in \code{origin} and \code{scale}.
\item[\code{include}] List of variables to carry unchanged from the original
dataframe to the output dataframe.
\item[\code{data}] Dataframe in which to interpret the arguments.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
The \code{data} is assumed to be a dataframe describing the follow-up
of a cohort, giving entry and exit time (on the input timescale) for each
individual as well as the exit status (failure status,
\code{fail}). The purpose of the function is to split each
individual's follow-up time along a number of timescales for example
age, calendar time, time since entry etc.
Any follow-up time before the first break
on any timescale or after the last break on any of these timescales
(the output timescales) is discarded.

NOTE: If a person has his/her exit before the first break or his entry
after the last break on any of the timescales the function will crash.
\end{Details}
\begin{Value}
A dataframe with one row per follow-up interval, with the following
variables: \begin{ldescription}
\item[\code{Expand}] A numerical vector with values in
\code{1:nrows(data)}, pointing at the rows of the input data frame
that is expanded to the output intervals.
\item[\code{Entry}] Date of entry for each interval. On the input time scale.
\item[\code{Exit}] Date of exit for each interval. On the input time scale.
\item[\code{Fail}] Exit status for each interval. Coded 0 for censoring, for
the last follow-up interval for each person it takes the value of
\code{fail}.
\item[\code{Time}] If \code{origin}, \code{scale} or \code{breaks} were given
as vectors this gives the left endpoints of the intervals
on the output scale.

If \code{origin}, \code{scale} or
\code{breaks}, were given as lists, there is no variable \code{Time}
in the dataframe, instead variables with the same names as
the list elements of these will be in the dataframe. The variables
have values corresponding to the left endpoints of the intervals on
the respective output time scales.
\item[\code{}] 
\end{ldescription}
 Finally, variables given in the argument \code{include}, values
replicated across all intervals from each individual.
\end{Value}
\begin{Author}\relax
David Clayton, approx. 2000.
Small modifications by Bendix Carstensen.
\end{Author}
\begin{References}\relax
This function has approximately the same functionality as
\code{stsplit} in Stata and the SAS-macro \code{\%Lexis}
(\url{http://www.biostat.ku.dk/~bxc/Lexis/Lexis.sas}). It has been
attempted to keep argument names similar between the three functions.
\end{References}
\begin{SeeAlso}\relax
\code{\LinkA{Lexis}{Lexis}},\code{\LinkA{Lexis.diagram}{Lexis.diagram}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# A small bogus cohort
#
xcoh <- structure( list( id = c("A", "B", "C"),
                      birth = c("14/07/1952", "01/04/1954", "10/06/1987"),
                      entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                       exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                       fail = c(1, 0, 1) ),
                     .Names = c("id", "birth", "entry", "exit", "fail"),
                  row.names = c("1", "2", "3"),
                      class = "data.frame" )

# Convert the character dates into numerical variables (fractional years)
#
xcoh$bt <- cal.yr( xcoh$birth, format="%d/%m/%Y" )
xcoh$en <- cal.yr( xcoh$entry, format="%d/%m/%Y" )
xcoh$ex <- cal.yr( xcoh$exit , format="%d/%m/%Y" )

# See how it looks
#
xcoh 

# Split time along one time-axis
#
W.Lexis( entry = en,
          exit = ex,
          fail = fail,
         scale = 1,
        origin = bt,
        breaks = seq( 5, 40, 5 ),
       include = list( bt, en, ex, id ),
          data = xcoh )

# Split time along two time-axes
#
( x2 <- 
W.Lexis( entry = en,
          exit = ex,
          fail = fail,
         scale = 1,
        origin = list( per=0,                 age=bt          ),
        breaks = list( per=seq(1900,2000,10), age=seq(0,80,5) ),
       include = list( bt, en, ex, id ),
          data = xcoh ) )

# Tabulate the cases and the person-years
#
tapply( x2$Fail, list( x2$age, x2$per ), sum )
tapply( x2$Exit - x2$Entry, list( x2$age, x2$per ), sum )
\end{ExampleCode}
\end{Examples}

\end{document}
