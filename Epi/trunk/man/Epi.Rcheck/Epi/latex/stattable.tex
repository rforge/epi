\HeaderA{stat.table}{Tables of summary statistics}{stat.table}
\aliasA{print.stat.table}{stat.table}{print.stat.table}
\keyword{iteration}{stat.table}
\keyword{category}{stat.table}
\begin{Description}\relax
\code{stat.table} creates tabular summaries of the data, using a
limited set of functions. A list of index variables is used
to cross-classify summary statistics.
\end{Description}
\begin{Usage}
\begin{verbatim}
stat.table(index, contents = count(), data, margins = FALSE)
print.stat.table(x, width=7, digits,...)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{index}] A factor, or list of factors, used for cross-classification.
If the list is named, then the names will be used when printing the
table. This feature can be used to give informative labels to the
variables.
\item[\code{contents}] A function call, or list of function calls. Only a
limited set of functions may be called (See Details below).  If the
list is named, then the names will be used when printing the table.
\item[\code{data}] an optional data frame containing the variables to be
tabulated. If this is omitted, the variables will be searched for in the
calling environment.
\item[\code{margins}] a logical scalar or vector indicating which  marginal
tables are to be calculated.  If a vector, it should be the same
length as the \code{index} argument: values corresponding to
\code{TRUE} will be retained in marginal tables.
\item[\code{x}] an object of class \code{stat.table}.
\item[\code{width}] a scalar giving the minimum column width when printing.
\item[\code{digits}] a scalar, or named vector, giving the number
of digits to print after the decimal point. If a named vector is used,
the names should correspond to one of the permitted functions (See
Details below) and all results obtained with that function will be
printed with the same precision.
\item[\code{...}] further arguments passed to other print methods.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
This function is similar to \code{tapply}, with some enhancements:
multiple summaries of multiple variables may be mixed in the
same table; marginal tables may be calculated; columns and rows may
be given informative labels; pretty printing may be controlled by the
associated print method.

This function is not a replacement for \code{tapply} as it also has
some limitations.  The only functions that may be used in the
\code{contents} argument  are: \code{\LinkA{count}{count}},
\code{\LinkA{mean}{mean}}, \code{\LinkA{weighted.mean}{weighted.mean}}, \code{\LinkA{sum}{sum}},
\code{\LinkA{quantile}{quantile}}, \code{\LinkA{median}{median}}, \code{\LinkA{IQR}{IQR}},
\code{\LinkA{max}{max}}, \code{\LinkA{min}{min}}, \code{\LinkA{ratio}{ratio}}, and
\code{\LinkA{percent}{percent}}.

The \code{count()} function, which is the default, simply creates a
contingency table of counts.  The other functions are applied to
each cell created by combinations of the \code{index} variables.
\end{Details}
\begin{Value}
An object of class \code{stat.table}, which is a multi-dimensional
array. A print method is available to create formatted one-way and
two-way tables.
\end{Value}
\begin{Note}\relax
The permitted functions in the contents list 
are defined inside \code{stat.table}.  They have the same interface as
the functions callable from the command line, except for two
differences. If there is an argument \code{na.rm} then its default
value is always \code{TRUE}. A second difference is that the
\code{quantile} function can only produce a single quantile in each call.
\end{Note}
\begin{Author}\relax
Martyn Plummer
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{table}{table}}, \code{\LinkA{tapply}{tapply}},
\code{\LinkA{mean}{mean}}, \code{\LinkA{weighted.mean}{weighted.mean}},
\code{\LinkA{sum}{sum}}, \code{\LinkA{quantile}{quantile}},
\code{\LinkA{median}{median}}, \code{\LinkA{IQR}{IQR}},
\code{\LinkA{max}{max}}, \code{\LinkA{min}{min}}, \code{\LinkA{ratio}{ratio}},
\code{\LinkA{percent}{percent}}, \code{\LinkA{count}{count}}
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
data(warpbreaks)
# A one-way table
stat.table(tension,list(count(),mean(breaks)),data=warpbreaks)
# The same table with informative labels
stat.table(index=list("Tension level"=tension),list(N=count(),
           "mean number of breaks"=mean(breaks)),data=warpbreaks)

# A two-way table
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks)  
# The same table with margins over tension, but not wool
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks,
           margins=c(TRUE, FALSE))

# A table of column percentages
stat.table(list(tension,wool), percent(tension), data=warpbreaks)
# Cell percentages, with margins
stat.table(list(tension,wool),percent(tension,wool), margin=TRUE,
           data=warpbreaks)

# A table with multiple statistics
# Note how each statistic has its own default precision
a <- stat.table(index=list(wool,tension),
                contents=list(count(),mean(breaks),percent (wool)),
                data=warpbreaks)
print(a)
# Print the percentages rounded to the nearest integer
print(a, digits=c(percent=0))

# An Epidemiological example with follow-up time
data(nickel)
str(nickel)

# Make a grouped version of the exposure variable
nickel$egr <- cut( nickel$exposure, breaks=c(0, 0.5, 5, 10, 100), right=FALSE )
stat.table( egr, list( count(), percent(egr), mean( age1st ) ), data=nickel )

# Split the follow-up time by current age
nickel.ex <-
W.Lexis( entry=agein, exit=ageout, fail=icd %in% c(162,163),
         origin=0, breaks=seq(0,100,20),
         include=list( id, exposure, egr, age1st, icd ), data=nickel )
str( nickel.ex )

# Table of rates
stat.table( Time, list( n=count(), N=count(id), D=sum(Fail),
                        "Rate/1000"=ratio(Fail,Exit-Entry,1000) ),
            margin=1, data=nickel.ex )
# Two-way table of rates and no. persons contributing
stat.table( list(age=Time, Exposure=egr),
            list( N=count(id), D=sum(Fail), Y=sum((Exit-Entry)/1000),
                  Rate=ratio(Fail,Exit-Entry,1000) ),
            margin=TRUE, data=nickel.ex )
\end{ExampleCode}
\end{Examples}

